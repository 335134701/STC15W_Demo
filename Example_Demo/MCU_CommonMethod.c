#include "MCU_CommonMethod.h"

//========================================================================
// 函数: void Delay_ms(unsigned int time)
// 描述: 软件延时函数
// 参数: time:延时时间
// 返回: 无
// 说明：单片机频率不同，延时效果不同
// 版本: V1.0, 2020.03.09
//========================================================================
void Delay_ms(unsigned int time)
{
    unsigned int x, y;
    for(x = time; x > 0; x--)
        for(y = 110; y > 0; y--);
}
//========================================================================
// 函数: void UART_BUF_Init()
// 描述: 初始化串口接收相关参数或设置
// 参数: 无
// 返回: 无
// 说明：此函数主要初始化串口设置参数
// 版本: V1.0, 2020.03.09
//========================================================================
void UART_BUF_Init()
{
    RX1_len = 0;
    memset(RX1_Buffer, 0, sizeof(RX1_Buffer));
}
//========================================================================
// 函数: unsigned char Uart_Pretreatment()
// 描述: 数据接收预处理函数
// 参数: 无
// 返回: 无
// 说明：此函数主要处理，接收字符串，并校验字符串
// 版本: V1.0, 2020.03.09
//========================================================================
unsigned char Uart_Pretreatment()
{
    //Check_protocol_flag表示接收数据是否有效标记位
    unsigned char Check_protocol_flag = 0;
		if((RX1_len > 0) && !B_TX1_Busy) {
				if( RX1_Buffer[0]==0xFF || RX1_Buffer[1]==0xFF )
				{
						if(RX1_len>(MinOrder+5)){UART_BUF_Init();}	
						if(RX1_len>=MinOrder && (HexToInt(RX1_Buffer[2])*pow(16,2)+HexToInt(RX1_Buffer[3])+4)==RX1_len){
								Check_protocol_flag = Check_Protocol(RX1_Buffer, RX1_len);
						}	
				}else{
						UART_BUF_Init();
				}
    }else{
				UART_BUF_Init();
		}
    return Check_protocol_flag;
}

//========================================================================
// 函数: unsigned char Calculate_Checksum(unsigned char *Buf,unsigned int Buf_len)
// 描述: 计算校验和
// 参数: *Buf:字符数组,Buf_len:数组实际长度
// 返回: 无
// 说明：无
// 版本: V1.0, 2020.03.09
//========================================================================
unsigned char Calculate_Checksum(unsigned char *Buf, unsigned int Buf_len)
{
    unsigned char checksum = 0x00;
    unsigned int i = 0, len = Buf_len;
    for(i = 2; i < (len - 1); i++) {
        checksum = checksum + Buf[i];
    }
    checksum = checksum % 256;
    return checksum;
}

//========================================================================
// 函数: unsigned char Check_Protocol(unsigned char *Buf,unsigned int Buf_len)
// 描述: 检验校验和是否一致
// 参数: *Buf:字符数组,Buf_len:数组实际长度
// 返回: 无
// 说明：具体思想为：接收到的BUF，取校验和，计算新的校验和，对比是否一致，若不一致，则数据无效
// 版本: V1.0, 2020.03.09
//========================================================================
unsigned char Check_Protocol(unsigned char *Buf, unsigned int Buf_len)
{
    unsigned char Check_protocol_flag = 0;
    //将原BUF的校验和提取
    unsigned char old_checksum = 0xFF;
    unsigned char new_checksum = 0x00;
		if(Buf_len>0){old_checksum = Buf[Buf_len - 1];}
    //计算新的校验和并赋值给new_checksum
    new_checksum = Calculate_Checksum(Buf, Buf_len);
    //比较原校验和与新校验和是否一致
    if(new_checksum == old_checksum) {
        Check_protocol_flag = 1;
    }
    return Check_protocol_flag;
}

//========================================================================
// 函数: void Data_Encapsulation(unsigned int Buf_len,unsigned char order,sn,action)
// 描述: 根据需要，打包数据并发送
// 参数: *Buf:字符数组,Buf_len:数组实际长度
// 返回: 无
// 说明：无
// 版本: V1.0, 2020.03.09
//========================================================================
void Data_Encapsulation(unsigned int Buf_len, unsigned char order, sn, action)
{
		unsigned char *Buf;
    //判断是否询问产品信息
    if(Buf_len != sizeof(Device_information)) {
				Buf=(unsigned char*)calloc(Buf_len,sizeof(unsigned char));
				memset(Buf, 0, sizeof(Buf));
				Buf[0]=0xFF;Buf[1]=0xFF;
        switch(Buf_len) {
        case 9:
            Buf[3] = 0x05;
            break;
        case 10:
            Buf[3] = 0x06;
            break;
        case 11:
            Buf[3] = 0x07;
            break;
        case 12:
            Buf[3] = 0x08;
            break;
        case 14:
            Buf[3] = 0x0A;
            Buf[9] = (P1 >> 4 & 0X0F);
            Buf[10] = 1;
            Buf[11] = 0x00;
            Buf[12] = 0x00;
            break;
        }
        Buf[4] = order;
        Buf[5] = sn;
        if(Buf_len != 9) {
            Buf[8] = action;
        }
    }
    //计算校验和
    Buf[Buf_len - 1] = Calculate_Checksum(Buf, Buf_len);
    //串口1回复数据
    SendString1(Buf, Buf_len);
}
//========================================================================
// 函数: void IsConnect_wifi()
// 描述: 判断是否接收到心跳包，如果没有接收到表示，连接wifi失败
// 参数: *Buf:字符数组,Buf_len:数组实际长度
// 返回: 无
// 说明：无
// 版本: V1.0, 2020.03.09
//========================================================================
void IsConnect_wifi()
{
    if((Wifi_flag == 1) && (Timer0_Count == 0)) {
        TR0 = 1;
    }
    //超过一分钟还未收到心跳包，即单片机与wifi模块失去联系
    if(Timer0_Count >= 12000) {
        TR0 = 0;
        Timer0_Count = 0;
        Wifi_flag = 0x00;
        Net_flag = 0;
        Phone_flag = 0;
        OLED_CLS_Local(0, 2, X_WIDTH, Y_WIDTH);
        OLED_P6x8Str(36, 4, "Wifi loss!");
    }
}
//========================================================================
// 函数: void HexToInt(unsigned char Buf)
// 描述: 十六进转十进制
// 参数: Buf:十进制字符
// 返回: 十进制数
// 说明：无
// 版本: V1.0, 2020.03.09
//========================================================================
unsigned int HexToInt(unsigned char Buf)
{
    unsigned char Nibble[2]={0};
    unsigned int tmp=0;
    Nibble[0] = Buf & 0x0F;
    Nibble[1] = Buf >> 4 & 0X0F;
    tmp = Nibble[0]*pow(16,0);
    tmp = tmp+Nibble[1]*pow(16,1);
    return tmp;
}
