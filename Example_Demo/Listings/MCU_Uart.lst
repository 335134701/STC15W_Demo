C51 COMPILER V9.60.0.0   MCU_UART                                                          11/26/2020 21:16:05 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE MCU_UART
OBJECT MODULE PLACED IN .\Objects\MCU_Uart.obj
COMPILER INVOKED BY: D:\Keil5\C51\BIN\C51.EXE MCU_Uart.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listi
                    -ngs\MCU_Uart.lst) TABS(2) OBJECT(.\Objects\MCU_Uart.obj)

line level    source

   1          #include  "MCU_Uart.h"
   2          
   3          /*************  本地变量声明  **************/
   4          unsigned char xdata RX1_Buffer[RX1_Length]; //接收缓冲
   5          //unsigned char xdata RX2_Buffer[RX2_Length]; //接收缓冲
   6          //unsigned char xdata RX3_Buffer[RX3_Length]; //接收缓冲
   7          //unsigned char xdata RX4_Buffer[RX4_Length]; //接收缓冲
   8          
   9          unsigned char RX1_len;  //接收数据长度
  10          //unsigned char RX2_len;  //接收数据长度
  11          //unsigned char RX3_len;  //接收数据长度
  12          //unsigned char RX4_len;  //接收数据长度
  13          
  14          bit B_TX1_Busy,B_TX2_Busy;  // 发送忙标志
  15          //bit B_TX1_Busy,B_TX2_Busy,B_TX3_Busy,B_TX4_Busy;  // 发送忙标志
  16          //========================================================================
  17          // UART引脚说明:
  18          // UART1:(默认)P3^0,P3^1;   (可选)P3^6,P3^7; P1^6,P1^7;
  19          // UART2:(默认)P1^0,P1^1;   (可选)P4^6,P4^7;
  20          // UART3:(默认)P0^0,P0^1;   (可选)P5^0,P5^1;
  21          // UART4:(默认)P0^2,P0^3;   (可选)P5^2,P5^3;
  22          //========================================================================
  23          
  24          void  UART1_config(unsigned char brt);
  25          void  UART2_config(unsigned char brt);
  26          //void  UART3_config(unsigned char brt);
  27          //void  UART4_config(unsigned char brt);
  28          
  29          
  30          //========================================================================
  31          // 函数: void Uart_Init(void)
  32          // 描述: Uart初始化函数
  33          // 参数: 无
  34          // 返回: 无
  35          // 版本: V1.0, 2020.03.09
  36          //========================================================================
  37          void Uart_Init(void)
  38          {
  39   1        UART1_config(2);  // 选择波特率, 2: 使用Timer2做波特率, 其它值: 使用Timer1做波特率.
  40   1        UART2_config(2);  // 选择波特率, 2: 使用Timer2做波特率, 其它值: 无效.
  41   1        /*
  42   1        UART2_config(2);  // 选择波特率, 2: 使用Timer2做波特率, 其它值: 无效.
  43   1        UART3_config(3);  // 选择波特率, 2: 使用Timer2做波特率, 其它值: 使用Timer3做波特率.
  44   1        UART4_config(4);  // 选择波特率, 2: 使用Timer2做波特率, 其它值: 使用Timer4做波特率.
  45   1        */
  46   1      }
  47          //========================================================================
  48          // 函数: SetTimer2Baudraye(unsigned int dat)
  49          // 描述: 设置Timer2做波特率发生器。
  50          // 参数: dat: Timer2的重装值.
  51          // 返回: none.
  52          // 版本: VER1.0
  53          // 日期: 2020-03-08
  54          // 备注: 
C51 COMPILER V9.60.0.0   MCU_UART                                                          11/26/2020 21:16:05 PAGE 2   

  55          //========================================================================
  56          void  SetTimer2Baudraye(unsigned int dat) //使用Timer2做波特率
  57          {
  58   1        AUXR &= ~(1<<4);  //Timer stop
  59   1        AUXR &= ~(1<<3);  //Timer2 set As Timer
  60   1        AUXR |=  (1<<2);  //Timer2 set as 1T mode
  61   1        TH2 = dat / 256;
  62   1        TL2 = dat % 256;
  63   1        IE2  &= ~(1<<2);  //禁止中断
  64   1        AUXR |=  (1<<4);  //Timer run enable
  65   1      }
  66          
  67          //========================================================================
  68          // 函数: void UART1_config(unsigned char brt)
  69          // 描述: UART1初始化函数。
  70          // 参数: brt: 选择波特率, 2: 使用Timer2做波特率, 其它值: 使用Timer1做波特率.
  71          // 返回: none.
  72          // 版本: VER1.0
  73          // 日期: 2020-03-08
  74          // 备注: 
  75          //========================================================================
  76          void  UART1_config(unsigned char brt) 
  77          {
  78   1        // 波特率使用定时器2
  79   1        if(brt == 2)
  80   1        {
  81   2          AUXR |= 0x01;   //S1 BRT Use Timer2;
  82   2          SetTimer2Baudraye(65536UL - (MAIN_Fosc / 4) / UART_BaudRate1);
  83   2        }
  84   1      
  85   1        // 波特率使用定时器1
  86   1        else
  87   1        {
  88   2          TR1 = 0;
  89   2          AUXR &= ~0x01;    //S1 BRT Use Timer1;
  90   2          AUXR |=  (1<<6);  //Timer1 set as 1T mode
  91   2          TMOD &= ~(1<<6);  //Timer1 set As Timer
  92   2          TMOD &= ~0x30;    //Timer1_16bitAutoReload;
  93   2          TH1 = (65536UL - (MAIN_Fosc / 4) / UART_BaudRate1) / 256;
  94   2          TL1 = (65536UL - (MAIN_Fosc / 4) / UART_BaudRate1) % 256;
  95   2          ET1 = 0;  //禁止中断
  96   2          INT_CLKO &= ~0x02;  //不输出时钟
  97   2          TR1  = 1;
  98   2        }
  99   1        /*************************************************/
 100   1        SCON = (SCON & 0x3f) | (1<<6);  // 8位数据, 1位起始位, 1位停止位, 无校验
 101   1      //PS  = 1;  //高优先级中断
 102   1        ES  = 1;  //允许中断
 103   1        REN = 1;  //允许接收
 104   1        P_SW1 = P_SW1 & 0x3f; //切换到 P3.0 P3.1
 105   1      
 106   1      //P_SW1 = (P_SW1 & 0x3f) | (1<<6);  //切换到P3.6 P3.7
 107   1      //P_SW1 = (P_SW1 & 0x3f) | (2<<6);  //切换到P1.6 P1.7 (必须使用内部时钟)
 108   1      
 109   1        memset(RX1_Buffer,0,RX1_Length);
 110   1        B_TX1_Busy  = 0;
 111   1        RX1_len   = 0;
 112   1      }
 113          
 114          
 115          //========================================================================
 116          // 函数: void UART2_config(unsigned char brt)
C51 COMPILER V9.60.0.0   MCU_UART                                                          11/26/2020 21:16:05 PAGE 3   

 117          // 描述: UART2初始化函数。
 118          // 参数: brt: 选择波特率, 2: 使用Timer2(定时器工作方式1)做波特率, 其它值: 无效.
 119          // 返回: none.
 120          // 版本: VER1.0
 121          // 日期: 2020-03-08
 122          // 备注: 
 123          //========================================================================
 124          void  UART2_config(unsigned char brt) // 选择波特率, 2: 使用Timer2做波特率, 其它值: 无效.
 125          {
 126   1        // 波特率固定使用定时器2
 127   1        if(brt == 2)  SetTimer2Baudraye(65536UL - (MAIN_Fosc / 4) / UART_BaudRate2);
 128   1      
 129   1        S2CON &= ~(1<<7); // 8位数据, 1位起始位, 1位停止位, 无校验
 130   1        IE2   |= 1;     //允许中断
 131   1        S2CON |= (1<<4);  //允许接收
 132   1        P_SW2 &= ~1;    //切换到 P1.0 P1.1
 133   1      //P_SW2 |= 1;     //切换到 P4.6 P4.7
 134   1      
 135   1        //memset(RX2_Buffer,0,RX2_Length);
 136   1        //B_TX2_Busy  = 0;
 137   1        //RX2_len   = 0;
 138   1      }
 139          /*
 140          //========================================================================
 141          // 函数: void UART3_config(unsigned char brt)
 142          // 描述: UART3初始化函数。
 143          // 参数: brt: 选择波特率, 2: 使用Timer2做波特率, 其它值: 使用Timer3做波特率.
 144          // 返回: none.
 145          // 版本: VER1.0
 146          // 日期: 2020-03-08
 147          // 备注: 
 148          //========================================================================
 149          void  UART3_config(unsigned char brt) // 选择波特率, 2: 使用Timer2做波特率, 其它值: 使用Timer3做波特率.
 150          {
 151            //波特率固定使用定时器2 
 152            if(brt == 2)
 153            {
 154              S3CON &= ~(1<<6); //BRT select Timer2
 155              SetTimer2Baudraye(65536UL - (MAIN_Fosc / 4) / UART_BaudRate3);
 156            }
 157            // 波特率使用定时器3
 158            else
 159            {
 160              S3CON |= (1<<6);  //BRT select Timer3
 161              T4T3M &= 0xf0;    //停止计数, 清除控制位
 162              IE2  &= ~(1<<5);  //禁止中断
 163              T4T3M |=  (1<<1); //1T
 164              T4T3M &= ~(1<<2); //定时
 165              T4T3M &= ~1;    //不输出时钟
 166              TH3 = (65536UL - (MAIN_Fosc / 4) / UART_BaudRate3) / 256;
 167              TL3 = (65536UL - (MAIN_Fosc / 4) / UART_BaudRate3) % 256;
 168              T4T3M |=  (1<<3); //开始运行
 169            }
 170            S3CON &= ~(1<<5); //禁止多机通讯方式
 171            S3CON &= ~(1<<7); // 8位数据, 1位起始位, 1位停止位, 无校验
 172            IE2   |=  (1<<3); //允许中断
 173            S3CON |=  (1<<4); //允许接收
 174            P_SW2 &= ~2;    //切换到 P0.0 P0.1
 175          //  P_SW2 |= 2;     //切换到 P5.0 P5.1
 176          
 177            memset(RX3_Buffer,0,RX3_Length);
 178            B_TX3_Busy  = 0;
C51 COMPILER V9.60.0.0   MCU_UART                                                          11/26/2020 21:16:05 PAGE 4   

 179            RX3_len   = 0;
 180          }
 181          
 182          //========================================================================
 183          // 函数: void UART4_config(unsigned char brt)
 184          // 描述: UART4初始化函数。
 185          // 参数: brt: 选择波特率, 2: 使用Timer2做波特率, 其它值: 使用Timer4做波特率.
 186          // 返回: none.
 187          // 版本: VER1.0
 188          // 日期: 2020-03-08
 189          // 备注: 
 190          //========================================================================
 191          void  UART4_config(unsigned char brt) // 选择波特率, 2: 使用Timer2做波特率, 其它值: 使用Timer4做波特率.
 192          {
 193            // 波特率固定使用定时器2
 194            if(brt == 2)
 195            {
 196              S4CON &= ~(1<<6); //BRT select Timer2
 197              SetTimer2Baudraye(65536UL - (MAIN_Fosc / 4) / UART_BaudRate4);
 198            }
 199            // 波特率使用定时器3
 200            else
 201            {
 202              S4CON |= (1<<6);  //BRT select Timer4
 203              T4T3M &= 0x0f;    //停止计数, 清除控制位
 204              IE2   &= ~(1<<6); //禁止中断
 205              T4T3M |=  (1<<5); //1T
 206              T4T3M &= ~(1<<6); //定时
 207              T4T3M &= ~(1<<4); //不输出时钟
 208              TH4 = (65536UL - (MAIN_Fosc / 4) / UART_BaudRate4) / 256;
 209              TL4 = (65536UL - (MAIN_Fosc / 4) / UART_BaudRate4) % 256;
 210              T4T3M |=  (1<<7); //开始运行
 211            }
 212            
 213            S4CON &= ~(1<<5); //禁止多机通讯方式
 214            S4CON &= ~(1<<7); // 8位数据, 1位起始位, 1位停止位, 无校验
 215            IE2   |=  (1<<4); //允许中断
 216            S4CON |=  (1<<4); //允许接收
 217            P_SW2 &= ~4;    //切换到 P0.2 P0.3
 218          //  P_SW2 |= 4;     //切换到 P5.2 P5.3
 219          
 220            memset(RX4_Buffer,0,RX4_Length);
 221            B_TX4_Busy  = 0;
 222            RX4_len   = 0;
 223          }
 224          */
 225          //========================================================================
 226          // 函数: void SendString1(unsigned char *puts,unsigned int len)
 227          // 描述: Uart1发送数据函数
 228          // 参数: *puts: 发送数据
 229          // 返回: none.
 230          // 版本: VER1.0
 231          // 日期: 2020-03-08
 232          // 备注: 
 233          //========================================================================
 234          void SendString1(unsigned char *puts,unsigned int len)
 235          {
 236   1         unsigned int i=0;
 237   1         for (i=0; i<len; i++)
 238   1         {
 239   2            B_TX1_Busy = 1;   //标志发送忙
 240   2            SBUF = puts[i];   //发一个字节
C51 COMPILER V9.60.0.0   MCU_UART                                                          11/26/2020 21:16:05 PAGE 5   

 241   2            while(B_TX1_Busy);  //等待发送完成
 242   2          }
 243   1      }
 244          //========================================================================
 245          // 函数: void SendString2(unsigned char *puts,unsigned int len)
 246          // 描述: Uart1发送数据函数
 247          // 参数: *puts: 发送数据
 248          // 返回: none.
 249          // 版本: VER1.0
 250          // 日期: 2020-03-08
 251          // 备注: 
 252          //========================================================================
 253          void SendString2(unsigned char *puts,unsigned int len)
 254          {
 255   1         unsigned int i=0;
 256   1         for (i=0; i<len; i++)
 257   1         {
 258   2            B_TX2_Busy = 1;   //标志发送忙
 259   2            S2BUF = puts[i];    //发一个字节
 260   2            while(B_TX2_Busy);  //等待发送完成
 261   2          }
 262   1      }
 263          /*
 264          //========================================================================
 265          // 函数: SendString3(unsigned char *puts)
 266          // 描述: Uart1发送数据函数
 267          // 参数: *puts: 发送数据
 268          // 返回: none.
 269          // 版本: VER1.0
 270          // 日期: 2020-03-08
 271          // 备注: 
 272          //========================================================================
 273          void SendString3(unsigned char *puts)
 274          {
 275              for (; *puts != 0;  puts++)
 276              {
 277                B_TX3_Busy = 1;   //标志发送忙
 278                S3BUF = *puts;    //发一个字节
 279                while(B_TX3_Busy);  //等待发送完成
 280              }
 281          }
 282          //========================================================================
 283          // 函数: SendString4(unsigned char *puts)
 284          // 描述: Uart1发送数据函数
 285          // 参数: *puts: 发送数据
 286          // 返回: none.
 287          // 版本: VER1.0
 288          // 日期: 2020-03-08
 289          // 备注: 
 290          //========================================================================
 291          void SendString4(unsigned char *puts)
 292          {
 293              for (; *puts != 0;  puts++)
 294              {
 295                B_TX4_Busy = 1;   //标志发送忙
 296                S4BUF = *puts;    //发一个字节
 297                while(B_TX4_Busy);  //等待发送完成
 298              }
 299          }
 300          */
 301          //========================================================================
 302          // 函数: void UART1_int (void) interrupt UART1_VECTOR
C51 COMPILER V9.60.0.0   MCU_UART                                                          11/26/2020 21:16:05 PAGE 6   

 303          // 描述: Uart1中断触发函数  
 304          // 参数: none
 305          // 返回: none.
 306          // 版本: VER1.0
 307          // 日期: 2020-03-08
 308          // 备注: 
 309          //========================================================================
 310          void UART1_int (void) interrupt UART1_VECTOR
 311          {
 312   1        if(RI)
 313   1        {
 314   2          RI = 0;
 315   2          RX1_Buffer[RX1_len] = SBUF;
 316   2          if(++RX1_len >= RX1_Length) RX1_len = 0;
 317   2        }
 318   1      
 319   1        if(TI)
 320   1        {
 321   2          TI = 0;
 322   2          B_TX1_Busy = 0;
 323   2        }
 324   1      }
 325          
 326          //========================================================================
 327          // 函数: void UART2_int (void) interrupt UART2_VECTOR
 328          // 描述: Uart2中断触发函数
 329          // 参数: none
 330          // 返回: none.
 331          // 版本: VER1.0
 332          // 日期: 2020-03-08
 333          // 备注: 
 334          //========================================================================
 335          void UART2_int (void) interrupt UART2_VECTOR
 336          {
 337   1        if(RI2)
 338   1        {
 339   2          CLR_RI2();
 340   2          //RX2_Buffer[RX2_len] = S2BUF;
 341   2          //if(++RX2_len >= RX2_Length) RX2_len = 0;
 342   2        }
 343   1      
 344   1        if(TI2)
 345   1        {
 346   2          CLR_TI2();
 347   2          B_TX2_Busy = 0;
 348   2        }
 349   1      
 350   1      }
 351          /*
 352          //========================================================================
 353          // 函数: void UART3_int (void) interrupt UART3_VECTOR
 354          // 描述: Uart3中断触发函数
 355          // 参数: none
 356          // 返回: none.
 357          // 版本: VER1.0
 358          // 日期: 2020-03-08
 359          // 备注: 
 360          //========================================================================
 361          void UART3_int (void) interrupt UART3_VECTOR
 362          {
 363            if(RI3)
 364            {
C51 COMPILER V9.60.0.0   MCU_UART                                                          11/26/2020 21:16:05 PAGE 7   

 365              CLR_RI3();
 366              RX3_Buffer[RX3_len] = S3BUF;
 367              if(++RX3_len >= RX3_Length) RX3_len = 0;
 368            }
 369            if(TI3)
 370            {
 371              CLR_TI3();
 372              B_TX3_Busy = 0;
 373            }
 374          
 375          }
 376          
 377          //========================================================================
 378          // 函数: void UART4_int (void) interrupt UART4_VECTOR
 379          // 描述: Uart4中断触发函数
 380          // 参数: none
 381          // 返回: none.
 382          // 版本: VER1.0
 383          // 日期: 2020-03-08
 384          // 备注: 
 385          //========================================================================
 386          void UART4_int (void) interrupt UART4_VECTOR
 387          {
 388            if(RI4)
 389            {
 390              CLR_RI4();
 391              RX4_Buffer[RX4_len] = S4BUF;
 392              if(++RX4_len >= RX4_Length) RX4_len = 0;
 393            }
 394          
 395            if(TI4)
 396            {
 397              CLR_TI4();
 398              B_TX4_Busy = 0;
 399            }
 400          }
 401          */


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    361    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    257      10
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      2    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
