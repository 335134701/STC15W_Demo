C51 COMPILER V9.60.0.0   MCU_HAND_UART                                                     12/13/2020 19:46:28 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE MCU_HAND_UART
OBJECT MODULE PLACED IN .\Objects\MCU_Hand_Uart.obj
COMPILER INVOKED BY: D:\Keil5\C51\BIN\C51.EXE ..\Example\MCU_Hand_Uart.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTE
                    -ND PRINT(.\Listings\MCU_Hand_Uart.lst) TABS(2) OBJECT(.\Objects\MCU_Hand_Uart.obj)

line level    source

   1          #include "MCU_Hand_Uart.h"
   2          
   3          unsigned char ConfigWifiMode = 0x00;
   4          
   5          //========================================================================
   6          // 函数: unsigned char Uart_Prereception_Layer()
   7          // 描述: 数据接收预处理函数
   8          // 参数: 无
   9          // 返回: 无
  10          // 说明：此函数主要处理，接收字符串，并校验字符串
  11          // 版本: V1.0, 2020.03.09
  12          //========================================================================
  13          unsigned char Uart_Prereception_Layer()
  14          {
  15   1          //Check_protocol_flag表示接收数据是否有效标记位
  16   1          unsigned char Check_protocol_flag = 0;
  17   1          if(RX1_len > 0 && !B_TX1_Busy && RX1_Buffer[0] == 0xFF) {
  18   2              if(RX1_len > 2) {
  19   3                  if(RX1_Buffer[1] == 0xFF) {
  20   4                      if(RX1_len > (MinOrder + 5)) {
  21   5                          UART_BUF_Init();
  22   5                      }
  23   4                      if((RX1_Buffer[2] * 16 * 16 + RX1_Buffer[3] + 4) == RX1_len) {
  24   5                          Check_protocol_flag = Check_Protocol(RX1_Buffer, RX1_len);
  25   5                          if(!Check_protocol_flag) {
  26   6                              UART_BUF_Init();
  27   6                          }
  28   5                      }
  29   4                  } else {
  30   4                      UART_BUF_Init();
  31   4                  }
  32   3              }
  33   2          } else {
  34   2              UART_BUF_Init();
  35   2          }
  36   1          return Check_protocol_flag;
  37   1      }
  38          
  39          //========================================================================
  40          // 函数: void Uart_Transmission_Layer(unsigned int Buf_len,unsigned char order,sn,action)
  41          // 描述: 串口数据发送处理函数
  42          // 参数: Buf_len:发送数组实际长度;order:协议命令标记;action:协议action标记
  43          // 返回: 无
  44          // 说明：无
  45          // 版本: V1.0, 2020.03.09
  46          //========================================================================
  47          void Uart_Transmission_Layer(unsigned int Buf_len, unsigned char order, action)
  48          {
  49   1          unsigned char Buf[116] = {0};
  50   1          memcpy(Buf, PublicAgreement, sizeof(PublicAgreement));
  51   1          Buf[3] = Buf_len - 4;
  52   1          Buf[4] = order;
  53   1          Buf[5] = Sn;
  54   1          //上传设备信息
C51 COMPILER V9.60.0.0   MCU_HAND_UART                                                     12/13/2020 19:46:28 PAGE 2   

  55   1          if(order == 0x02) {
  56   2              memcat(Buf, SerialProVersion, 8, sizeof(SerialProVersion));
  57   2              memcat(Buf, BusinessProVersion, 16, sizeof(BusinessProVersion));
  58   2              memcat(Buf, HardVersion, 24, sizeof(HardVersion));
  59   2              memcat(Buf, SoftVersion, 32, sizeof(SoftVersion));
  60   2              memcat(Buf, ProductKey, 40, sizeof(ProductKey));
  61   2              memcat(Buf, DeviceAttributes, 74, sizeof(DeviceAttributes));
  62   2              memcat(Buf, ProductSecert, 82, sizeof(ProductSecert));
  63   2          }
  64   1          //接收非法数据包
  65   1          if(order == 0x12) {
  66   2              Buf[8] = action;
  67   2          }
  68   1          //上传设备状态
  69   1          if((order == 0x04 && action == 0x03) || (order == 0x05 && action == 0x04)) {
  70   2              Buf[8] = action;
  71   2              Buf[9] = P1 >> 4 & 0X0F;
  72   2              Buf[10] = 0;
  73   2              Buf[11] = 0x00;
  74   2              Buf[12] = 0x00;
  75   2          }
  76   1          //计算校验和
  77   1          Buf[Buf_len - 1] = Calculate_Checksum(Buf, Buf_len);
  78   1          //串口1回复数据
  79   1          SendString1(Buf, Buf_len);
  80   1      }
  81          /*
  82          void Uart_Transmission_Layer(unsigned int Buf_len, unsigned char order, action)
  83          {
  84              unsigned char Buf[116] = {0};
  85              unsigned char *tmp=NULL;
  86              memcpy(Buf, PublicAgreement, sizeof(PublicAgreement));
  87              tmp=Buf+sizeof(PublicAgreement);
  88              Buf[3] = Buf_len - 4;
  89              Buf[4] = order;
  90              Buf[5] = Sn;
  91              //上传设备信息
  92              if(order == 0x02) {
  93                  memcpy(tmp,SerialProVersion,sizeof(SerialProVersion));
  94                  tmp=tmp+sizeof(SerialProVersion);
  95                  memcpy(tmp,BusinessProVersion,sizeof(BusinessProVersion));
  96                  tmp=tmp+sizeof(BusinessProVersion);
  97                  memcpy(tmp,HardVersion,sizeof(HardVersion));
  98                  tmp=tmp+sizeof(HardVersion);
  99                  memcpy(tmp,SoftVersion,sizeof(SoftVersion));
 100                  tmp=tmp+sizeof(SoftVersion);
 101                  memcpy(tmp,ProductKey,sizeof(ProductKey));
 102                  tmp=tmp+sizeof(ProductKey)+2;
 103                  memcpy(tmp,DeviceAttributes,sizeof(DeviceAttributes));
 104                  tmp=tmp+sizeof(DeviceAttributes);
 105                  memcpy(tmp,ProductSecert,sizeof(ProductSecert));
 106              }
 107              //接收非法数据包
 108              if(order == 0x12) {
 109                  Buf[8] = action;
 110              }
 111              //上传设备状态
 112              if((order == 0x04 && action == 0x03) || (order == 0x05 && action == 0x04)) {
 113                  Buf[8] = action;
 114                  Buf[9] = P1 >> 4 & 0X0F;
 115                  Buf[10] = 0;
 116                  Buf[11] = 0x00;
C51 COMPILER V9.60.0.0   MCU_HAND_UART                                                     12/13/2020 19:46:28 PAGE 3   

 117                  Buf[12] = 0x00;
 118              }
 119              //计算校验和
 120              Buf[Buf_len - 1] = Calculate_Checksum(Buf, Buf_len);
 121              //串口1回复数据
 122              SendString1(Buf, Buf_len);
 123          }
 124          */
 125          //========================================================================
 126          // 函数: void IsConnect_wifi()
 127          // 描述: 判断是否接收到心跳包，如果没有接收到表示，连接wifi失败
 128          // 参数: *Buf:字符数组,Buf_len:数组实际长度
 129          // 返回: 无
 130          // 说明：无
 131          // 版本: V1.0, 2020.03.09
 132          //========================================================================
 133          void IsConnect_wifi()
 134          {
 135   1          //说明wifi模块已经连接成功，开启定时器
 136   1          if((Wifi_flag == 1) && (Timer0_Count == 0)) {
 137   2              TR0 = 1;
 138   2          }
 139   1          //超过三分钟还未收到心跳包，即单片机与wifi模块失去联系
 140   1          //定时器的时间为5ms
 141   1          if(Timer0_Count >= 36000) {
 142   2              TR0 = 0;            //定时器0 初始化关闭
 143   2              Timer0_Count = 0;   //定时器0计数位
 144   2              Wifi_flag = 0x00;   //wifi连接模块标记位初始化
 145   2              Net_flag = 0;       //网络标记位初始化
 146   2              Phone_flag = 0;     //手机连接标记位初始化
 147   2              OLED_CLS_Local(0, 2, X_WIDTH, Y_WIDTH);
 148   2              OLED_P6x8Str(36, 4, "Wifi loss!");
 149   2          }
 150   1      }
 151          
 152          //========================================================================
 153          // 函数: void UART_Send_Servvice_Layer()
 154          // 描述: UART1发送业务处理函数
 155          // 参数: 无
 156          // 返回: 无
 157          // 版本: V1.0, 2020.04.24
 158          //========================================================================
 159          void UART_Send_Servvice_Layer()
 160          {
 161   1          if(Set_soft_flag == 0 || Set_AP_flag == 0 || Reset_message_flag == 0 || Bindable_wifi_flag == 0 || Res
             -tart_wifi_flag == 0) {
 162   2              Delay_ms(10);
 163   2              OLED_CLS_Local(0, 2, X_WIDTH, Y_WIDTH);
 164   2              if(Sn != 0x00) {
 165   3                  Sn = Sn + 0x01;
 166   3              }
 167   2              //  配置WiFi模式(Soft模式)
 168   2              if(Set_soft_flag == 0) {
 169   3                  ConfigWifiMode = 0x01;
 170   3                  Uart_Transmission_Layer(10, 0x09, ConfigWifiMode);
 171   3              }
 172   2              //  配置WiFi模式(AP模式)
 173   2              if(Set_AP_flag == 0)        {
 174   3                  ConfigWifiMode = 0x02;
 175   3                 Uart_Transmission_Layer(10, 0x09, ConfigWifiMode);
 176   3              }
 177   2              //  重置WiFi信息
C51 COMPILER V9.60.0.0   MCU_HAND_UART                                                     12/13/2020 19:46:28 PAGE 4   

 178   2              if(Reset_message_flag == 0) {
 179   3                 Uart_Transmission_Layer(9, 0x0b, 0x00);
 180   3              }
 181   2              //  WiFi进入可绑定模式
 182   2              if(Bindable_wifi_flag == 0) {
 183   3                 Uart_Transmission_Layer(9, 0x15, 0x00);
 184   3              }
 185   2              //   重启WiFi模组
 186   2              if(Restart_wifi_flag == 0)  {
 187   3                 Uart_Transmission_Layer(9, 0x29, 0x00);
 188   3              }
 189   2              while(Set_soft_flag == 0 || Set_AP_flag == 0 || Reset_message_flag == 0 || Bindable_wifi_flag == 0
             - || Restart_wifi_flag == 0);
 190   2          }
 191   1        
 192   1      }
 193          
 194          //========================================================================
 195          // 函数: void UART_Receive_Service_Layer()
 196          // 描述: UART1接收业务处理函数
 197          // 参数: 无
 198          // 返回: 无
 199          // 版本: V1.0, 2020.04.24
 200          //========================================================================
 201          void UART_Receive_Service_Layer()
 202          {
 203   1        
 204   1        //校验接收数据的合法性
 205   1          if(Uart_Prereception_Layer()) {
 206   2              //获取包序号并赋值给Sn
 207   2              Sn = RX1_Buffer[5];
 208   2              switch(RX1_Buffer[4]) {
 209   3              //WiFi模组获取设备信息
 210   3              case 0x01:
 211   3                  Uart_Transmission_Layer(115, RX1_Buffer[4] + 1, 0x00);
 212   3                  break;
 213   3              //WiFi模组控制设备,读取设备的当前状态
 214   3              case 0x03:
 215   3                  //WiFi模 组 控 制 设 备
 216   3                  if(RX1_Buffer[8] == 0x01) {
 217   4                      //收到数据后，mcu控制设备函数
 218   4                      MCU_Application_Control(RX1_Buffer);
 219   4                      Uart_Transmission_Layer(9, RX1_Buffer[4] + 1, 0x00);
 220   4                      //MCU主动上报当前状态
 221   4                      Sn = Sn + 0x01;
 222   4                      Uart_Transmission_Layer(14, RX1_Buffer[4] + 2, 0x04);
 223   4                      MCU_OLED_StatusChange(RX1_Buffer[9]);
 224   4                  }
 225   3                  // WiFi模 组 读 取 设 备 的 当 前 状 态
 226   3                  if(RX1_Buffer[8] == 0x02) {
 227   4                      Uart_Transmission_Layer(14, RX1_Buffer[4] + 1, RX1_Buffer[8] + 1);
 228   4                  }
 229   3                  break;
 230   3              //MCU主动上报当前状态WIFI模组回复
 231   3              case 0x06:
 232   3                  break;
 233   3              //WiFi模组向MCU发送心跳
 234   3              case 0x07:
 235   3                  Wifi_flag = 0x01;
 236   3                  //关闭定时器，将计数器置0
 237   3                  TR0 = 0;
 238   3                  Timer0_Count = 0;
C51 COMPILER V9.60.0.0   MCU_HAND_UART                                                     12/13/2020 19:46:28 PAGE 5   

 239   3                  Uart_Transmission_Layer(9, RX1_Buffer[4] + 1, 0x00);
 240   3                  //打开定时器
 241   3                  TR0 = 1;
 242   3                  break;
 243   3              //通知WIFI模组进入配置模式后接收WIFI模组回复
 244   3              case 0x0a:
 245   3                  if(ConfigWifiMode == 0x01) {
 246   4                      OLED_P6x8Str(2, 2, "Configure Wifi:Soft");
 247   4                  } else {
 248   4                      OLED_P6x8Str(2, 2, "Configure Wifi:AP");
 249   4                  }
 250   3                  break;
 251   3              //重置WiFi模组后接收WIFI模组回复
 252   3              case 0x0c:
 253   3                  OLED_P6x8Str(2, 2, "Reset Wifi!");
 254   3                  break;
 255   3              //WiFi模组向MCU推送WiFi状态
 256   3              case 0x0d:
 257   3                  //将手机连接标志位，网络连接标志位初始化
 258   3                  Phone_flag = 0;
 259   3                  Net_flag = 0;
 260   3                  Wifi_flag = 0x01;
 261   3                  //展示WiFi连接信息
 262   3                  MCU_WIFI_MessageShow(RX1_Buffer[4], RX1_Buffer[8], RX1_Buffer[9]);
 263   3                  if(RX1_Buffer[8] >= 0x00 && RX1_Buffer[8] <= 0x07 ) Net_flag = 1;
 264   3                  if(RX1_Buffer[8] >= 0x08 && RX1_Buffer[8] <= 0x0F ) {
 265   4                      Net_flag = 1;
 266   4                      Phone_flag = 1;
 267   4                  }
 268   3                  //如果有手机连接 展示产品连接信息
 269   3                  MCU_OLED_StatusChange(0x00);
 270   3                  Uart_Transmission_Layer(9, RX1_Buffer[4] + 1, 0x00);
 271   3                  break;
 272   3              case 0x0f:
 273   3                  Uart_Transmission_Layer(9, RX1_Buffer[4] + 1, 0x00);
 274   3                  break;
 275   3              //WiFi模组非法数据包通知
 276   3              case 0x11:
 277   3                  Uart_Transmission_Layer(10, RX1_Buffer[4] + 1, RX1_Buffer[8]);
 278   3                  break;
 279   3              //MCU请求WiFi进入可绑定模式，WiFi模组回复
 280   3              case 0x16:
 281   3                  OLED_P6x8Str(2, 2, "Enter bindable mode!");
 282   3                  break;
 283   3              //MCU请求获取网络时间，WiFi模组回复
 284   3              case 0x18:
 285   3                  break;
 286   3              //MCU请求WiFi重启，WiFi模组回复
 287   3              case 0x2a:
 288   3                  OLED_P6x8Str(2, 2, "Restart Wifi!");
 289   3                  break;
 290   3              }
 291   2              UART_BUF_Init();
 292   2          }
 293   1          
 294   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1277    ----
   CONSTANT SIZE    =    212    ----
   XDATA SIZE       =      1     122
C51 COMPILER V9.60.0.0   MCU_HAND_UART                                                     12/13/2020 19:46:28 PAGE 6   

   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
