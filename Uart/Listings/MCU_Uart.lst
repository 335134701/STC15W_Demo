C51 COMPILER V9.60.0.0   MCU_UART                                                          04/11/2020 18:15:03 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE MCU_UART
OBJECT MODULE PLACED IN .\Objects\MCU_Uart.obj
COMPILER INVOKED BY: D:\Keil5\C51\BIN\C51.EXE MCU_Uart.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listi
                    -ngs\MCU_Uart.lst) TABS(2) OBJECT(.\Objects\MCU_Uart.obj)

line level    source

   1          #include  "MCU_Config.h"
   2          
   3          /*************  本地变量声明  **************/
   4          u8 xdata  RX1_Buffer[RX1_Length]; //接收缓冲
   5          u8 xdata  RX2_Buffer[RX2_Length]; //接收缓冲
   6          u8 xdata  RX3_Buffer[RX3_Length]; //接收缓冲
   7          u8 xdata  RX4_Buffer[RX4_Length]; //接收缓冲
   8          
   9          u8 RX1_len; //接收数据长度
  10          u8 RX2_len; //接收数据长度
  11          u8 RX3_len; //接收数据长度
  12          u8 RX4_len; //接收数据长度
  13          
  14          bit B_TX1_Busy,B_TX2_Busy,B_TX3_Busy,B_TX4_Busy;  // 发送忙标志
  15          //========================================================================
  16          // UART引脚说明:
  17          // UART1:(默认)P3^0,P3^1;   (可选)P3^6,P3^7; P1^6,P1^7;
  18          // UART2:(默认)P1^0,P1^1;   (可选)P4^6,P4^7;
  19          // UART3:(默认)P0^0,P0^1;   (可选)P5^0,P5^1;
  20          // UART4:(默认)P0^2,P0^3;   (可选)P5^2,P5^3;
  21          //========================================================================
  22          
  23          
  24          
  25          //========================================================================
  26          // 函数: void Uart_Init(void)
  27          // 描述: Uart初始化函数
  28          // 参数: 无
  29          // 返回: 无
  30          // 版本: V1.0, 2020.03.09
  31          //========================================================================
  32          void Uart_Init(void)
  33          {
  34   1        UART1_config(2);  // 选择波特率, 2: 使用Timer2做波特率, 其它值: 使用Timer1做波特率.
  35   1        UART2_config(2);  // 选择波特率, 2: 使用Timer2做波特率, 其它值: 无效.
  36   1        UART3_config(2);  // 选择波特率, 2: 使用Timer2做波特率, 其它值: 使用Timer3做波特率.
  37   1        UART4_config(2);  // 选择波特率, 2: 使用Timer2做波特率, 其它值: 使用Timer4做波特率.
  38   1        /*
  39   1        UART2_config(2);  // 选择波特率, 2: 使用Timer2做波特率, 其它值: 无效.
  40   1        UART3_config(3);  // 选择波特率, 2: 使用Timer2做波特率, 其它值: 使用Timer3做波特率.
  41   1        UART4_config(4);  // 选择波特率, 2: 使用Timer2做波特率, 其它值: 使用Timer4做波特率.
  42   1        */
  43   1      }
  44          //========================================================================
  45          // 函数: SetTimer2Baudraye(u16 dat)
  46          // 描述: 设置Timer2做波特率发生器。
  47          // 参数: dat: Timer2的重装值.
  48          // 返回: none.
  49          // 版本: VER1.0
  50          // 日期: 2020-03-08
  51          // 备注: 
  52          //========================================================================
  53          void  SetTimer2Baudraye(u16 dat)  //使用Timer2做波特率
  54          {
C51 COMPILER V9.60.0.0   MCU_UART                                                          04/11/2020 18:15:03 PAGE 2   

  55   1        AUXR &= ~(1<<4);  //Timer stop
  56   1        AUXR &= ~(1<<3);  //Timer2 set As Timer
  57   1        AUXR |=  (1<<2);  //Timer2 set as 1T mode
  58   1        TH2 = dat / 256;
  59   1        TL2 = dat % 256;
  60   1        IE2  &= ~(1<<2);  //禁止中断
  61   1        AUXR |=  (1<<4);  //Timer run enable
  62   1      }
  63          
  64          //========================================================================
  65          // 函数: void UART1_config(u8 brt)
  66          // 描述: UART1初始化函数。
  67          // 参数: brt: 选择波特率, 2: 使用Timer2做波特率, 其它值: 使用Timer1做波特率.
  68          // 返回: none.
  69          // 版本: VER1.0
  70          // 日期: 2020-03-08
  71          // 备注: 
  72          //========================================================================
  73          void  UART1_config(u8 brt)  
  74          {
  75   1        /*********** 波特率使用定时器2 *****************/
  76   1        if(brt == 2)
  77   1        {
  78   2          AUXR |= 0x01;   //S1 BRT Use Timer2;
  79   2          SetTimer2Baudraye(65536UL - (MAIN_Fosc / 4) / UART_BaudRate1);
  80   2        }
  81   1      
  82   1        /*********** 波特率使用定时器1 *****************/
  83   1        else
  84   1        {
  85   2          TR1 = 0;
  86   2          AUXR &= ~0x01;    //S1 BRT Use Timer1;
  87   2          AUXR |=  (1<<6);  //Timer1 set as 1T mode
  88   2          TMOD &= ~(1<<6);  //Timer1 set As Timer
  89   2          TMOD &= ~0x30;    //Timer1_16bitAutoReload;
  90   2          TH1 = (65536UL - (MAIN_Fosc / 4) / UART_BaudRate1) / 256;
  91   2          TL1 = (65536UL - (MAIN_Fosc / 4) / UART_BaudRate1) % 256;
  92   2          ET1 = 0;  //禁止中断
  93   2          INT_CLKO &= ~0x02;  //不输出时钟
  94   2          TR1  = 1;
  95   2        }
  96   1        /*************************************************/
  97   1        SCON = (SCON & 0x3f) | (1<<6);  // 8位数据, 1位起始位, 1位停止位, 无校验
  98   1      //PS  = 1;  //高优先级中断
  99   1        ES  = 1;  //允许中断
 100   1        REN = 1;  //允许接收
 101   1        P_SW1 = P_SW1 & 0x3f; //切换到 P3.0 P3.1
 102   1      
 103   1      //P_SW1 = (P_SW1 & 0x3f) | (1<<6);  //切换到P3.6 P3.7
 104   1      //P_SW1 = (P_SW1 & 0x3f) | (2<<6);  //切换到P1.6 P1.7 (必须使用内部时钟)
 105   1      
 106   1        memset(RX1_Buffer,0,RX1_Length);
 107   1        B_TX1_Busy  = 0;
 108   1        RX1_len   = 0;
 109   1      }
 110          
 111          
 112          //========================================================================
 113          // 函数: void UART2_config(u8 brt)
 114          // 描述: UART2初始化函数。
 115          // 参数: brt: 选择波特率, 2: 使用Timer2(定时器工作方式1)做波特率, 其它值: 无效.
 116          // 返回: none.
C51 COMPILER V9.60.0.0   MCU_UART                                                          04/11/2020 18:15:03 PAGE 3   

 117          // 版本: VER1.0
 118          // 日期: 2020-03-08
 119          // 备注: 
 120          //========================================================================
 121          void  UART2_config(u8 brt)  // 选择波特率, 2: 使用Timer2做波特率, 其它值: 无效.
 122          {
 123   1        /*********** 波特率固定使用定时器2 *****************/
 124   1        if(brt == 2)  SetTimer2Baudraye(65536UL - (MAIN_Fosc / 4) / UART_BaudRate2);
 125   1      
 126   1        S2CON &= ~(1<<7); // 8位数据, 1位起始位, 1位停止位, 无校验
 127   1        IE2   |= 1;     //允许中断
 128   1        S2CON |= (1<<4);  //允许接收
 129   1        P_SW2 &= ~1;    //切换到 P1.0 P1.1
 130   1      //P_SW2 |= 1;     //切换到 P4.6 P4.7
 131   1      
 132   1        memset(RX2_Buffer,0,RX2_Length);
 133   1        B_TX2_Busy  = 0;
 134   1        RX2_len   = 0;
 135   1      }
 136          
 137          //========================================================================
 138          // 函数: void UART3_config(u8 brt)
 139          // 描述: UART3初始化函数。
 140          // 参数: brt: 选择波特率, 2: 使用Timer2做波特率, 其它值: 使用Timer3做波特率.
 141          // 返回: none.
 142          // 版本: VER1.0
 143          // 日期: 2020-03-08
 144          // 备注: 
 145          //========================================================================
 146          void  UART3_config(u8 brt)  // 选择波特率, 2: 使用Timer2做波特率, 其它值: 使用Timer3做波特率.
 147          {
 148   1        /*********** 波特率固定使用定时器2 *****************/
 149   1        if(brt == 2)
 150   1        {
 151   2          S3CON &= ~(1<<6); //BRT select Timer2
 152   2          SetTimer2Baudraye(65536UL - (MAIN_Fosc / 4) / UART_BaudRate3);
 153   2        }
 154   1        /*********** 波特率使用定时器3 *****************/
 155   1        else
 156   1        {
 157   2          S3CON |= (1<<6);  //BRT select Timer3
 158   2          T4T3M &= 0xf0;    //停止计数, 清除控制位
 159   2          IE2  &= ~(1<<5);  //禁止中断
 160   2          T4T3M |=  (1<<1); //1T
 161   2          T4T3M &= ~(1<<2); //定时
 162   2          T4T3M &= ~1;    //不输出时钟
 163   2          TH3 = (65536UL - (MAIN_Fosc / 4) / UART_BaudRate3) / 256;
 164   2          TL3 = (65536UL - (MAIN_Fosc / 4) / UART_BaudRate3) % 256;
 165   2          T4T3M |=  (1<<3); //开始运行
 166   2        }
 167   1        S3CON &= ~(1<<5); //禁止多机通讯方式
 168   1        S3CON &= ~(1<<7); // 8位数据, 1位起始位, 1位停止位, 无校验
 169   1        IE2   |=  (1<<3); //允许中断
 170   1        S3CON |=  (1<<4); //允许接收
 171   1        P_SW2 &= ~2;    //切换到 P0.0 P0.1
 172   1      //  P_SW2 |= 2;     //切换到 P5.0 P5.1
 173   1      
 174   1        memset(RX3_Buffer,0,RX3_Length);
 175   1        B_TX3_Busy  = 0;
 176   1        RX3_len   = 0;
 177   1      }
 178          
C51 COMPILER V9.60.0.0   MCU_UART                                                          04/11/2020 18:15:03 PAGE 4   

 179          //========================================================================
 180          // 函数: void UART4_config(u8 brt)
 181          // 描述: UART4初始化函数。
 182          // 参数: brt: 选择波特率, 2: 使用Timer2做波特率, 其它值: 使用Timer4做波特率.
 183          // 返回: none.
 184          // 版本: VER1.0
 185          // 日期: 2020-03-08
 186          // 备注: 
 187          //========================================================================
 188          void  UART4_config(u8 brt)  // 选择波特率, 2: 使用Timer2做波特率, 其它值: 使用Timer4做波特率.
 189          {
 190   1        /*********** 波特率固定使用定时器2 *****************/
 191   1        if(brt == 2)
 192   1        {
 193   2          S4CON &= ~(1<<6); //BRT select Timer2
 194   2          SetTimer2Baudraye(65536UL - (MAIN_Fosc / 4) / UART_BaudRate4);
 195   2        }
 196   1        /*********** 波特率使用定时器3 *****************/
 197   1        else
 198   1        {
 199   2          S4CON |= (1<<6);  //BRT select Timer4
 200   2          T4T3M &= 0x0f;    //停止计数, 清除控制位
 201   2          IE2   &= ~(1<<6); //禁止中断
 202   2          T4T3M |=  (1<<5); //1T
 203   2          T4T3M &= ~(1<<6); //定时
 204   2          T4T3M &= ~(1<<4); //不输出时钟
 205   2          TH4 = (65536UL - (MAIN_Fosc / 4) / UART_BaudRate4) / 256;
 206   2          TL4 = (65536UL - (MAIN_Fosc / 4) / UART_BaudRate4) % 256;
 207   2          T4T3M |=  (1<<7); //开始运行
 208   2        }
 209   1        
 210   1        S4CON &= ~(1<<5); //禁止多机通讯方式
 211   1        S4CON &= ~(1<<7); // 8位数据, 1位起始位, 1位停止位, 无校验
 212   1        IE2   |=  (1<<4); //允许中断
 213   1        S4CON |=  (1<<4); //允许接收
 214   1        P_SW2 &= ~4;    //切换到 P0.2 P0.3
 215   1      //  P_SW2 |= 4;     //切换到 P5.2 P5.3
 216   1      
 217   1        memset(RX4_Buffer,0,RX4_Length);
 218   1        B_TX4_Busy  = 0;
 219   1        RX4_len   = 0;
 220   1      }
 221          //========================================================================
 222          // 函数: SendString1(u8 *puts)
 223          // 描述: Uart1发送数据函数
 224          // 参数: *puts: 发送数据
 225          // 返回: none.
 226          // 版本: VER1.0
 227          // 日期: 2020-03-08
 228          // 备注: 
 229          //========================================================================
 230          void SendString1(u8 *puts)
 231          {
 232   1          for (; *puts != 0;  puts++)
 233   1          {
 234   2            B_TX1_Busy = 1;   //标志发送忙
 235   2            SBUF = *puts;   //发一个字节
 236   2            while(B_TX1_Busy);  //等待发送完成
 237   2          }
 238   1      }
 239          //========================================================================
 240          // 函数: SendString2(u8 *puts)
C51 COMPILER V9.60.0.0   MCU_UART                                                          04/11/2020 18:15:03 PAGE 5   

 241          // 描述: Uart1发送数据函数
 242          // 参数: *puts: 发送数据
 243          // 返回: none.
 244          // 版本: VER1.0
 245          // 日期: 2020-03-08
 246          // 备注: 
 247          //========================================================================
 248          void SendString2(u8 *puts)
 249          {
 250   1         for (; *puts != 0; puts++)
 251   1         {
 252   2            B_TX2_Busy = 1;   //标志发送忙
 253   2            S2BUF = *puts;    //发一个字节
 254   2            while(B_TX2_Busy);  //等待发送完成
 255   2          }
 256   1      }
 257          //========================================================================
 258          // 函数: SendString3(u8 *puts)
 259          // 描述: Uart1发送数据函数
 260          // 参数: *puts: 发送数据
 261          // 返回: none.
 262          // 版本: VER1.0
 263          // 日期: 2020-03-08
 264          // 备注: 
 265          //========================================================================
 266          void SendString3(u8 *puts)
 267          {
 268   1          for (; *puts != 0;  puts++)
 269   1          {
 270   2            B_TX3_Busy = 1;   //标志发送忙
 271   2            S3BUF = *puts;    //发一个字节
 272   2            while(B_TX3_Busy);  //等待发送完成
 273   2          }
 274   1      }
 275          //========================================================================
 276          // 函数: SendString4(u8 *puts)
 277          // 描述: Uart1发送数据函数
 278          // 参数: *puts: 发送数据
 279          // 返回: none.
 280          // 版本: VER1.0
 281          // 日期: 2020-03-08
 282          // 备注: 
 283          //========================================================================
 284          void SendString4(u8 *puts)
 285          {
 286   1          for (; *puts != 0;  puts++)
 287   1          {
 288   2            B_TX4_Busy = 1;   //标志发送忙
 289   2            S4BUF = *puts;    //发一个字节
 290   2            while(B_TX4_Busy);  //等待发送完成
 291   2          }
 292   1      }
 293          
 294          
 295          //========================================================================
 296          // 函数: Cl_RX_Buffer(u8 *puts,u8 *len)
 297          // 描述: Uart清理函数
 298          // 参数: *puts: 发送数据缓存，*len缓存中数据长度
 299          // 返回: none.
 300          // 版本: VER1.0
 301          // 日期: 2020-03-08
 302          // 备注: 
C51 COMPILER V9.60.0.0   MCU_UART                                                          04/11/2020 18:15:03 PAGE 6   

 303          //========================================================================
 304          void Cl_RX_Buffer(u8 *puts,u8 *len)
 305          {
 306   1        *len=0;
 307   1        memset(puts,0,*len);
 308   1      }
 309          
 310          
 311          /********************* UART1中断函数************************/
 312          void UART1_int (void) interrupt UART1_VECTOR
 313          {
 314   1        if(RI)
 315   1        {
 316   2          RI = 0;
 317   2          RX1_Buffer[RX1_len] = SBUF;
 318   2          if(++RX1_len >= RX1_Length) RX1_len = 0;
 319   2        }
 320   1      
 321   1        if(TI)
 322   1        {
 323   2          TI = 0;
 324   2          B_TX1_Busy = 0;
 325   2        }
 326   1      }
 327          
 328          /********************* UART2中断函数************************/
 329          void UART2_int (void) interrupt UART2_VECTOR
 330          {
 331   1        if(RI2)
 332   1        {
 333   2          CLR_RI2();
 334   2          RX2_Buffer[RX2_len] = S2BUF;
 335   2          if(++RX2_len >= RX2_Length) RX2_len = 0;
 336   2        }
 337   1      
 338   1        if(TI2)
 339   1        {
 340   2          CLR_TI2();
 341   2          B_TX2_Busy = 0;
 342   2        }
 343   1      
 344   1      }
 345          
 346          /********************* UART3中断函数************************/
 347          void UART3_int (void) interrupt UART3_VECTOR
 348          {
 349   1        if(RI3)
 350   1        {
 351   2          CLR_RI3();
 352   2          RX3_Buffer[RX3_len] = S3BUF;
 353   2          if(++RX3_len >= RX3_Length) RX3_len = 0;
 354   2        }
 355   1        if(TI3)
 356   1        {
 357   2          CLR_TI3();
 358   2          B_TX3_Busy = 0;
 359   2        }
 360   1      
 361   1      }
 362          
 363          /********************* UART4中断函数************************/
 364          void UART4_int (void) interrupt UART4_VECTOR
C51 COMPILER V9.60.0.0   MCU_UART                                                          04/11/2020 18:15:03 PAGE 7   

 365          {
 366   1        if(RI4)
 367   1        {
 368   2          CLR_RI4();
 369   2          RX4_Buffer[RX4_len] = S4BUF;
 370   2          if(++RX4_len >= RX4_Length) RX4_len = 0;
 371   2        }
 372   1      
 373   1        if(TI4)
 374   1        {
 375   2          CLR_TI4();
 376   2          B_TX4_Busy = 0;
 377   2        }
 378   1      
 379   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    737    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   1028       6
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      4    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
