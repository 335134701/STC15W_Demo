C51 COMPILER V9.60.0.0   MCU_UART                                                          07/06/2020 14:09:32 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE MCU_UART
OBJECT MODULE PLACED IN .\Objects\MCU_Uart.obj
COMPILER INVOKED BY: D:\Keil5\C51\BIN\C51.EXE MCU_Uart.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listi
                    -ngs\MCU_Uart.lst) TABS(2) OBJECT(.\Objects\MCU_Uart.obj)

line level    source

   1          #include  "MCU_Uart.h"
   2          
   3          void  UART1_config(unsigned char brt);
   4          void  UART2_config(unsigned char brt);
   5          //void  UART3_config(unsigned char brt);
   6          //void  UART4_config(unsigned char brt);
   7          
   8          /*************  本地变量声明  **************/
   9          unsigned char xdata RX1_Buffer[RX1_Length]; //接收缓冲
  10          //unsigned char xdata RX2_Buffer[RX2_Length]; //接收缓冲
  11          //unsigned char xdata RX3_Buffer[RX3_Length]; //接收缓冲
  12          //unsigned char xdata RX4_Buffer[RX4_Length]; //接收缓冲
  13          
  14          unsigned char RX1_len;  //接收数据长度
  15          //unsigned char RX2_len;  //接收数据长度
  16          //unsigned char RX3_len;  //接收数据长度
  17          //unsigned char RX4_len;  //接收数据长度
  18          
  19          bit B_TX1_Busy,B_TX2_Busy;
  20          //bit B_TX1_Busy,B_TX2_Busy,B_TX3_Busy,B_TX4_Busy;  // 发送忙标志
  21          //========================================================================
  22          // UART引脚说明:
  23          // UART1:(默认)P3^0,P3^1;   (可选)P3^6,P3^7; P1^6,P1^7;
  24          // UART2:(默认)P1^0,P1^1;   (可选)P4^6,P4^7;
  25          // UART3:(默认)P0^0,P0^1;   (可选)P5^0,P5^1;
  26          // UART4:(默认)P0^2,P0^3;   (可选)P5^2,P5^3;
  27          //========================================================================
  28          
  29          
  30          
  31          //========================================================================
  32          // 函数: void Uart_Init(void)
  33          // 描述: Uart初始化函数
  34          // 参数: 无
  35          // 返回: 无
  36          // 版本: V1.0, 2020.03.09
  37          //========================================================================
  38          void Uart_Init(void)
  39          {
  40   1        /******
  41   1        需要注意：定时器使用冲突问题，即Uart与Timer使用之间的冲突
  42   1        例如：如下串口使用Timer2，在Timer中对Timer2初始化需要做一定的更改
  43   1        *******/
  44   1        UART1_config(2);  // 选择波特率, 2: 使用Timer2做波特率, 其它值: 使用Timer1做波特率.
  45   1        UART2_config(2);  // 选择波特率, 2: 使用Timer2做波特率, 其它值: 无效.
  46   1        /*
  47   1        UART2_config(2);  // 选择波特率, 2: 使用Timer2做波特率, 其它值: 无效.
  48   1        UART3_config(3);  // 选择波特率, 2: 使用Timer2做波特率, 其它值: 使用Timer3做波特率.
  49   1        UART4_config(4);  // 选择波特率, 2: 使用Timer2做波特率, 其它值: 使用Timer4做波特率.
  50   1        */
  51   1      }
  52          //========================================================================
  53          // 函数: SetTimer2Baudraye(unsigned int dat)
  54          // 描述: 设置Timer2做波特率发生器。
C51 COMPILER V9.60.0.0   MCU_UART                                                          07/06/2020 14:09:32 PAGE 2   

  55          // 参数: dat: Timer2的重装值.
  56          // 返回: none.
  57          // 版本: VER1.0
  58          // 日期: 2020-03-08
  59          // 备注: 
  60          //========================================================================
  61          void  SetTimer2Baudraye(unsigned int dat) //使用Timer2做波特率
  62          {
  63   1        AUXR &= ~(1<<4);  //Timer stop
  64   1        AUXR &= ~(1<<3);  //Timer2 set As Timer
  65   1        AUXR |=  (1<<2);  //Timer2 set as 1T mode
  66   1        TH2 = dat / 256;
  67   1        TL2 = dat % 256;
  68   1        IE2  &= ~(1<<2);  //禁止中断
  69   1        AUXR |=  (1<<4);  //Timer run enable
  70   1      }
  71          
  72          //========================================================================
  73          // 函数: void UART1_config(unsigned char brt)
  74          // 描述: UART1初始化函数。
  75          // 参数: brt: 选择波特率, 2: 使用Timer2做波特率, 其它值: 使用Timer1做波特率.
  76          // 返回: none.
  77          // 版本: VER1.0
  78          // 日期: 2020-03-08
  79          // 备注: 
  80          //========================================================================
  81          void  UART1_config(unsigned char brt) 
  82          {
  83   1        /*********** 波特率使用定时器2 *****************/
  84   1        if(brt == 2)
  85   1        {
  86   2          AUXR |= 0x01;   //S1 BRT Use Timer2;
  87   2          SetTimer2Baudraye(65536UL - (MAIN_Fosc / 4) / UART_BaudRate1);
  88   2        }
  89   1      
  90   1        /*********** 波特率使用定时器1 *****************/
  91   1        else
  92   1        {
  93   2          TR1 = 0;
  94   2          AUXR &= ~0x01;    //S1 BRT Use Timer1;
  95   2          AUXR |=  (1<<6);  //Timer1 set as 1T mode
  96   2          TMOD &= ~(1<<6);  //Timer1 set As Timer
  97   2          TMOD &= ~0x30;    //Timer1_16bitAutoReload;
  98   2          TH1 = (65536UL - (MAIN_Fosc / 4) / UART_BaudRate1) / 256;
  99   2          TL1 = (65536UL - (MAIN_Fosc / 4) / UART_BaudRate1) % 256;
 100   2          ET1 = 0;  //禁止中断
 101   2          INT_CLKO &= ~0x02;  //不输出时钟
 102   2          TR1  = 1;
 103   2        }
 104   1        /*************************************************/
 105   1        SCON = (SCON & 0x3f) | (1<<6);  // 8位数据, 1位起始位, 1位停止位, 无校验
 106   1      //PS  = 1;  //高优先级中断
 107   1        ES  = 1;  //允许中断
 108   1        REN = 1;  //允许接收
 109   1        P_SW1 = P_SW1 & 0x3f; //切换到 P3.0 P3.1
 110   1      
 111   1      //P_SW1 = (P_SW1 & 0x3f) | (1<<6);  //切换到P3.6 P3.7
 112   1      //P_SW1 = (P_SW1 & 0x3f) | (2<<6);  //切换到P1.6 P1.7 (必须使用内部时钟)
 113   1      
 114   1        memset(RX1_Buffer,0,RX1_Length);
 115   1        B_TX1_Busy  = 0;
 116   1        RX1_len   = 0;
C51 COMPILER V9.60.0.0   MCU_UART                                                          07/06/2020 14:09:32 PAGE 3   

 117   1      }
 118          
 119          
 120          //========================================================================
 121          // 函数: void UART2_config(unsigned char brt)
 122          // 描述: UART2初始化函数。
 123          // 参数: brt: 选择波特率, 2: 使用Timer2(定时器工作方式1)做波特率, 其它值: 无效.
 124          // 返回: none.
 125          // 版本: VER1.0
 126          // 日期: 2020-03-08
 127          // 备注: 
 128          //========================================================================
 129          void  UART2_config(unsigned char brt) // 选择波特率, 2: 使用Timer2做波特率, 其它值: 无效.
 130          {
 131   1        /*********** 波特率固定使用定时器2 *****************/
 132   1        if(brt == 2)  SetTimer2Baudraye(65536UL - (MAIN_Fosc / 4) / UART_BaudRate2);
 133   1      
 134   1        S2CON &= ~(1<<7); // 8位数据, 1位起始位, 1位停止位, 无校验
 135   1        IE2   |= 1;     //允许中断
 136   1        S2CON |= (1<<4);  //允许接收
 137   1        P_SW2 &= ~1;    //切换到 P1.0 P1.1
 138   1      //P_SW2 |= 1;     //切换到 P4.6 P4.7
 139   1      
 140   1        //memset(RX2_Buffer,0,RX2_Length);
 141   1        //B_TX2_Busy  = 0;
 142   1        //RX2_len   = 0;
 143   1      }
 144          /*
 145          //========================================================================
 146          // 函数: void UART3_config(unsigned char brt)
 147          // 描述: UART3初始化函数。
 148          // 参数: brt: 选择波特率, 2: 使用Timer2做波特率, 其它值: 使用Timer3做波特率.
 149          // 返回: none.
 150          // 版本: VER1.0
 151          // 日期: 2020-03-08
 152          // 备注: 
 153          //========================================================================
 154          void  UART3_config(unsigned char brt) // 选择波特率, 2: 使用Timer2做波特率, 其它值: 使用Timer3做波特率.
 155          {
 156            if(brt == 2)
 157            {
 158              S3CON &= ~(1<<6); //BRT select Timer2
 159              SetTimer2Baudraye(65536UL - (MAIN_Fosc / 4) / UART_BaudRate3);
 160            }
 161            else
 162            {
 163              S3CON |= (1<<6);  //BRT select Timer3
 164              T4T3M &= 0xf0;    //停止计数, 清除控制位
 165              IE2  &= ~(1<<5);  //禁止中断
 166              T4T3M |=  (1<<1); //1T
 167              T4T3M &= ~(1<<2); //定时
 168              T4T3M &= ~1;    //不输出时钟
 169              TH3 = (65536UL - (MAIN_Fosc / 4) / UART_BaudRate3) / 256;
 170              TL3 = (65536UL - (MAIN_Fosc / 4) / UART_BaudRate3) % 256;
 171              T4T3M |=  (1<<3); //开始运行
 172            }
 173            S3CON &= ~(1<<5); //禁止多机通讯方式
 174            S3CON &= ~(1<<7); // 8位数据, 1位起始位, 1位停止位, 无校验
 175            IE2   |=  (1<<3); //允许中断
 176            S3CON |=  (1<<4); //允许接收
 177            P_SW2 &= ~2;    //切换到 P0.0 P0.1
 178          //  P_SW2 |= 2;     //切换到 P5.0 P5.1
C51 COMPILER V9.60.0.0   MCU_UART                                                          07/06/2020 14:09:32 PAGE 4   

 179          
 180            memset(RX3_Buffer,0,RX3_Length);
 181            B_TX3_Busy  = 0;
 182            RX3_len   = 0;
 183          }
 184          
 185          //========================================================================
 186          // 函数: void UART4_config(unsigned char brt)
 187          // 描述: UART4初始化函数。
 188          // 参数: brt: 选择波特率, 2: 使用Timer2做波特率, 其它值: 使用Timer4做波特率.
 189          // 返回: none.
 190          // 版本: VER1.0
 191          // 日期: 2020-03-08
 192          // 备注: 
 193          //========================================================================
 194          void  UART4_config(unsigned char brt) // 选择波特率, 2: 使用Timer2做波特率, 其它值: 使用Timer4做波特率.
 195          {
 196            if(brt == 2)
 197            {
 198              S4CON &= ~(1<<6); //BRT select Timer2
 199              SetTimer2Baudraye(65536UL - (MAIN_Fosc / 4) / UART_BaudRate4);
 200            }
 201            else
 202            {
 203              S4CON |= (1<<6);  //BRT select Timer4
 204              T4T3M &= 0x0f;    //停止计数, 清除控制位
 205              IE2   &= ~(1<<6); //禁止中断
 206              T4T3M |=  (1<<5); //1T
 207              T4T3M &= ~(1<<6); //定时
 208              T4T3M &= ~(1<<4); //不输出时钟
 209              TH4 = (65536UL - (MAIN_Fosc / 4) / UART_BaudRate4) / 256;
 210              TL4 = (65536UL - (MAIN_Fosc / 4) / UART_BaudRate4) % 256;
 211              T4T3M |=  (1<<7); //开始运行
 212            }
 213            
 214            S4CON &= ~(1<<5); //禁止多机通讯方式
 215            S4CON &= ~(1<<7); // 8位数据, 1位起始位, 1位停止位, 无校验
 216            IE2   |=  (1<<4); //允许中断
 217            S4CON |=  (1<<4); //允许接收
 218            P_SW2 &= ~4;    //切换到 P0.2 P0.3
 219          //  P_SW2 |= 4;     //切换到 P5.2 P5.3
 220          
 221            memset(RX4_Buffer,0,RX4_Length);
 222            B_TX4_Busy  = 0;
 223            RX4_len   = 0;
 224          }
 225          */
 226          //========================================================================
 227          // 函数: void SendString1(unsigned char *puts,unsigned int len)
 228          // 描述: Uart1发送数据函数
 229          // 参数: *puts: 发送数据
 230          // 返回: none.
 231          // 版本: VER1.0
 232          // 日期: 2020-03-08
 233          // 备注: 
 234          //========================================================================
 235          void SendString1(unsigned char *puts,unsigned int len)
 236          {
 237   1         unsigned int i=0;
 238   1         for (i=0; i<len; i++)
 239   1         {
 240   2            B_TX1_Busy = 1;   //标志发送忙
C51 COMPILER V9.60.0.0   MCU_UART                                                          07/06/2020 14:09:32 PAGE 5   

 241   2            SBUF = puts[i];   //发一个字节
 242   2            while(B_TX1_Busy);  //等待发送完成
 243   2          }
 244   1      }
 245          //========================================================================
 246          // 函数: void SendString2(unsigned char *puts,unsigned int len)
 247          // 描述: Uart1发送数据函数
 248          // 参数: *puts: 发送数据
 249          // 返回: none.
 250          // 版本: VER1.0
 251          // 日期: 2020-03-08
 252          // 备注: 
 253          //========================================================================
 254          void SendString2(unsigned char *puts,unsigned int len)
 255          {
 256   1         unsigned int i=0;
 257   1         for (i=0; i<len; i++)
 258   1         {
 259   2            B_TX2_Busy = 1;   //标志发送忙
 260   2            S2BUF = puts[i];    //发一个字节
 261   2            while(B_TX2_Busy);  //等待发送完成
 262   2          }
 263   1      }
 264          /*
 265          //========================================================================
 266          // 函数: SendString3(unsigned char *puts)
 267          // 描述: Uart1发送数据函数
 268          // 参数: *puts: 发送数据
 269          // 返回: none.
 270          // 版本: VER1.0
 271          // 日期: 2020-03-08
 272          // 备注: 
 273          //========================================================================
 274          void SendString3(unsigned char *puts)
 275          {
 276              for (; *puts != 0;  puts++)
 277              {
 278                B_TX3_Busy = 1;   //标志发送忙
 279                S3BUF = *puts;    //发一个字节
 280                while(B_TX3_Busy);  //等待发送完成
 281              }
 282          }
 283          //========================================================================
 284          // 函数: SendString4(unsigned char *puts)
 285          // 描述: Uart1发送数据函数
 286          // 参数: *puts: 发送数据
 287          // 返回: none.
 288          // 版本: VER1.0
 289          // 日期: 2020-03-08
 290          // 备注: 
 291          //========================================================================
 292          void SendString4(unsigned char *puts)
 293          {
 294              for (; *puts != 0;  puts++)
 295              {
 296                B_TX4_Busy = 1;   //标志发送忙
 297                S4BUF = *puts;    //发一个字节
 298                while(B_TX4_Busy);  //等待发送完成
 299              }
 300          }
 301          */
 302          //========================================================================
C51 COMPILER V9.60.0.0   MCU_UART                                                          07/06/2020 14:09:32 PAGE 6   

 303          // 函数: void UART1_int (void) interrupt UART1_VECTOR
 304          // 描述: Uart1中断触发函数
 305          // 参数: none
 306          // 返回: none.
 307          // 版本: VER1.0
 308          // 日期: 2020-03-08
 309          // 备注: 
 310          //========================================================================
 311          void UART1_int (void) interrupt UART1_VECTOR
 312          {
 313   1        if(RI)
 314   1        {
 315   2          RI = 0;
 316   2          RX1_Buffer[RX1_len] = SBUF;
 317   2          if(++RX1_len >= RX1_Length) RX1_len = 0;
 318   2        }
 319   1        if(TI)
 320   1        {
 321   2          TI = 0;
 322   2          B_TX1_Busy = 0;
 323   2        }
 324   1      }
 325          
 326          //========================================================================
 327          // 函数: void UART2_int (void) interrupt UART2_VECTOR
 328          // 描述: Uart2中断触发函数
 329          // 参数: none
 330          // 返回: none.
 331          // 版本: VER1.0
 332          // 日期: 2020-03-08
 333          // 备注: 
 334          //========================================================================
 335          void UART2_int (void) interrupt UART2_VECTOR
 336          {
 337   1        if(RI2)
 338   1        {
 339   2          CLR_RI2();
 340   2          //RX2_Buffer[RX2_len] = S2BUF;
 341   2          //if(++RX2_len >= RX2_Length) RX2_len = 0;
 342   2        }
 343   1      
 344   1        if(TI2)
 345   1        {
 346   2          CLR_TI2();
 347   2          B_TX2_Busy = 0;
 348   2        }
 349   1      
 350   1      }
 351          /*
 352          //========================================================================
 353          // 函数: void UART3_int (void) interrupt UART3_VECTOR
 354          // 描述: Uart3中断触发函数
 355          // 参数: none
 356          // 返回: none.
 357          // 版本: VER1.0
 358          // 日期: 2020-03-08
 359          // 备注: 
 360          //========================================================================
 361          void UART3_int (void) interrupt UART3_VECTOR
 362          {
 363            if(RI3)
 364            {
C51 COMPILER V9.60.0.0   MCU_UART                                                          07/06/2020 14:09:32 PAGE 7   

 365              CLR_RI3();
 366              RX3_Buffer[RX3_len] = S3BUF;
 367              if(++RX3_len >= RX3_Length) RX3_len = 0;
 368            }
 369            if(TI3)
 370            {
 371              CLR_TI3();
 372              B_TX3_Busy = 0;
 373            }
 374          
 375          }
 376          
 377          //========================================================================
 378          // 函数: void UART4_int (void) interrupt UART4_VECTOR
 379          // 描述: Uart4中断触发函数
 380          // 参数: none
 381          // 返回: none.
 382          // 版本: VER1.0
 383          // 日期: 2020-03-08
 384          // 备注: 
 385          //========================================================================
 386          void UART4_int (void) interrupt UART4_VECTOR
 387          {
 388            if(RI4)
 389            {
 390              CLR_RI4();
 391              RX4_Buffer[RX4_len] = S4BUF;
 392              if(++RX4_len >= RX4_Length) RX4_len = 0;
 393            }
 394          
 395            if(TI4)
 396            {
 397              CLR_TI4();
 398              B_TX4_Busy = 0;
 399            }
 400          
 401          }
 402          */


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    361    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    257      10
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      2    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
