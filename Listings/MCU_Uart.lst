C51 COMPILER V9.60.0.0   MCU_UART                                                          05/31/2020 15:59:08 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE MCU_UART
OBJECT MODULE PLACED IN .\Objects\MCU_Uart.obj
COMPILER INVOKED BY: D:\Keil5\C51\BIN\C51.EXE MCU_Uart.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\MC
                    -U_Uart.lst) TABS(2) OBJECT(.\Objects\MCU_Uart.obj)

line level    source

   1          #include  "MCU_Uart.h"
   2          
   3          void  UART1_config(unsigned char brt);
   4          void  UART2_config(unsigned char brt);
   5          void  UART3_config(unsigned char brt);
   6          void  UART4_config(unsigned char brt);
   7          
   8          /*************  本地变量声明  **************/
   9          unsigned char xdata RX1_Buffer[RX1_Length]; //接收缓冲
  10          unsigned char xdata RX2_Buffer[RX2_Length]; //接收缓冲
  11          unsigned char xdata RX3_Buffer[RX3_Length]; //接收缓冲
  12          unsigned char xdata RX4_Buffer[RX4_Length]; //接收缓冲
  13          
  14          unsigned char RX1_len;  //接收数据长度
  15          unsigned char RX2_len;  //接收数据长度
  16          unsigned char RX3_len;  //接收数据长度
  17          unsigned char RX4_len;  //接收数据长度
  18          
  19          bit B_TX1_Busy,B_TX2_Busy,B_TX3_Busy,B_TX4_Busy;  // 发送忙标志
  20          //========================================================================
  21          // UART引脚说明:
  22          // UART1:(默认)P3^0,P3^1;   (可选)P3^6,P3^7; P1^6,P1^7;
  23          // UART2:(默认)P1^0,P1^1;   (可选)P4^6,P4^7;
  24          // UART3:(默认)P0^0,P0^1;   (可选)P5^0,P5^1;
  25          // UART4:(默认)P0^2,P0^3;   (可选)P5^2,P5^3;
  26          //========================================================================
  27          
  28          
  29          
  30          //========================================================================
  31          // 函数: void Uart_Init(void)
  32          // 描述: Uart初始化函数
  33          // 参数: 无
  34          // 返回: 无
  35          // 版本: V1.0, 2020.03.09
  36          //========================================================================
  37          void Uart_Init(void)
  38          {
  39   1        /******
  40   1        需要注意：定时器使用冲突问题，即Uart与Timer使用之间的冲突
  41   1        例如：如下串口使用Timer2，在Timer中对Timer2初始化需要做一定的更改
  42   1        *******/
  43   1        UART1_config(2);  // 选择波特率, 2: 使用Timer2做波特率, 其它值: 使用Timer1做波特率.
  44   1        UART2_config(2);  // 选择波特率, 2: 使用Timer2做波特率, 其它值: 无效.
  45   1        UART3_config(2);  // 选择波特率, 2: 使用Timer2做波特率, 其它值: 使用Timer3做波特率.
  46   1        UART4_config(2);  // 选择波特率, 2: 使用Timer2做波特率, 其它值: 使用Timer4做波特率.
  47   1        /*
  48   1        UART2_config(2);  // 选择波特率, 2: 使用Timer2做波特率, 其它值: 无效.
  49   1        UART3_config(3);  // 选择波特率, 2: 使用Timer2做波特率, 其它值: 使用Timer3做波特率.
  50   1        UART4_config(4);  // 选择波特率, 2: 使用Timer2做波特率, 其它值: 使用Timer4做波特率.
  51   1        */
  52   1      }
  53          //========================================================================
  54          // 函数: SetTimer2Baudraye(unsigned int dat)
C51 COMPILER V9.60.0.0   MCU_UART                                                          05/31/2020 15:59:08 PAGE 2   

  55          // 描述: 设置Timer2做波特率发生器。
  56          // 参数: dat: Timer2的重装值.
  57          // 返回: none.
  58          // 版本: VER1.0
  59          // 日期: 2020-03-08
  60          // 备注: 
  61          //========================================================================
  62          void  SetTimer2Baudraye(unsigned int dat) //使用Timer2做波特率
  63          {
  64   1        AUXR &= ~(1<<4);  //Timer stop
  65   1        AUXR &= ~(1<<3);  //Timer2 set As Timer
  66   1        AUXR |=  (1<<2);  //Timer2 set as 1T mode
  67   1        TH2 = dat / 256;
  68   1        TL2 = dat % 256;
  69   1        IE2  &= ~(1<<2);  //禁止中断
  70   1        AUXR |=  (1<<4);  //Timer run enable
  71   1      }
  72          
  73          //========================================================================
  74          // 函数: void UART1_config(unsigned char brt)
  75          // 描述: UART1初始化函数。
  76          // 参数: brt: 选择波特率, 2: 使用Timer2做波特率, 其它值: 使用Timer1做波特率.
  77          // 返回: none.
  78          // 版本: VER1.0
  79          // 日期: 2020-03-08
  80          // 备注: 
  81          //========================================================================
  82          void  UART1_config(unsigned char brt) 
  83          {
  84   1        /*********** 波特率使用定时器2 *****************/
  85   1        if(brt == 2)
  86   1        {
  87   2          AUXR |= 0x01;   //S1 BRT Use Timer2;
  88   2          SetTimer2Baudraye(65536UL - (MAIN_Fosc / 4) / UART_BaudRate1);
  89   2        }
  90   1      
  91   1        /*********** 波特率使用定时器1 *****************/
  92   1        else
  93   1        {
  94   2          TR1 = 0;
  95   2          AUXR &= ~0x01;    //S1 BRT Use Timer1;
  96   2          AUXR |=  (1<<6);  //Timer1 set as 1T mode
  97   2          TMOD &= ~(1<<6);  //Timer1 set As Timer
  98   2          TMOD &= ~0x30;    //Timer1_16bitAutoReload;
  99   2          TH1 = (65536UL - (MAIN_Fosc / 4) / UART_BaudRate1) / 256;
 100   2          TL1 = (65536UL - (MAIN_Fosc / 4) / UART_BaudRate1) % 256;
 101   2          ET1 = 0;  //禁止中断
 102   2          INT_CLKO &= ~0x02;  //不输出时钟
 103   2          TR1  = 1;
 104   2        }
 105   1        /*************************************************/
 106   1        SCON = (SCON & 0x3f) | (1<<6);  // 8位数据, 1位起始位, 1位停止位, 无校验
 107   1      //PS  = 1;  //高优先级中断
 108   1        ES  = 1;  //允许中断
 109   1        REN = 1;  //允许接收
 110   1        P_SW1 = P_SW1 & 0x3f; //切换到 P3.0 P3.1
 111   1      
 112   1      //P_SW1 = (P_SW1 & 0x3f) | (1<<6);  //切换到P3.6 P3.7
 113   1      //P_SW1 = (P_SW1 & 0x3f) | (2<<6);  //切换到P1.6 P1.7 (必须使用内部时钟)
 114   1      
 115   1        memset(RX1_Buffer,0,RX1_Length);
 116   1        B_TX1_Busy  = 0;
C51 COMPILER V9.60.0.0   MCU_UART                                                          05/31/2020 15:59:08 PAGE 3   

 117   1        RX1_len   = 0;
 118   1      }
 119          
 120          
 121          //========================================================================
 122          // 函数: void UART2_config(unsigned char brt)
 123          // 描述: UART2初始化函数。
 124          // 参数: brt: 选择波特率, 2: 使用Timer2(定时器工作方式1)做波特率, 其它值: 无效.
 125          // 返回: none.
 126          // 版本: VER1.0
 127          // 日期: 2020-03-08
 128          // 备注: 
 129          //========================================================================
 130          void  UART2_config(unsigned char brt) // 选择波特率, 2: 使用Timer2做波特率, 其它值: 无效.
 131          {
 132   1        /*********** 波特率固定使用定时器2 *****************/
 133   1        if(brt == 2)  SetTimer2Baudraye(65536UL - (MAIN_Fosc / 4) / UART_BaudRate2);
 134   1      
 135   1        S2CON &= ~(1<<7); // 8位数据, 1位起始位, 1位停止位, 无校验
 136   1        IE2   |= 1;     //允许中断
 137   1        S2CON |= (1<<4);  //允许接收
 138   1        P_SW2 &= ~1;    //切换到 P1.0 P1.1
 139   1      //P_SW2 |= 1;     //切换到 P4.6 P4.7
 140   1      
 141   1        memset(RX2_Buffer,0,RX2_Length);
 142   1        B_TX2_Busy  = 0;
 143   1        RX2_len   = 0;
 144   1      }
 145          
 146          //========================================================================
 147          // 函数: void UART3_config(unsigned char brt)
 148          // 描述: UART3初始化函数。
 149          // 参数: brt: 选择波特率, 2: 使用Timer2做波特率, 其它值: 使用Timer3做波特率.
 150          // 返回: none.
 151          // 版本: VER1.0
 152          // 日期: 2020-03-08
 153          // 备注: 
 154          //========================================================================
 155          void  UART3_config(unsigned char brt) // 选择波特率, 2: 使用Timer2做波特率, 其它值: 使用Timer3做波特率.
 156          {
 157   1        /*********** 波特率固定使用定时器2 *****************/
 158   1        if(brt == 2)
 159   1        {
 160   2          S3CON &= ~(1<<6); //BRT select Timer2
 161   2          SetTimer2Baudraye(65536UL - (MAIN_Fosc / 4) / UART_BaudRate3);
 162   2        }
 163   1        /*********** 波特率使用定时器3 *****************/
 164   1        else
 165   1        {
 166   2          S3CON |= (1<<6);  //BRT select Timer3
 167   2          T4T3M &= 0xf0;    //停止计数, 清除控制位
 168   2          IE2  &= ~(1<<5);  //禁止中断
 169   2          T4T3M |=  (1<<1); //1T
 170   2          T4T3M &= ~(1<<2); //定时
 171   2          T4T3M &= ~1;    //不输出时钟
 172   2          TH3 = (65536UL - (MAIN_Fosc / 4) / UART_BaudRate3) / 256;
 173   2          TL3 = (65536UL - (MAIN_Fosc / 4) / UART_BaudRate3) % 256;
 174   2          T4T3M |=  (1<<3); //开始运行
 175   2        }
 176   1        S3CON &= ~(1<<5); //禁止多机通讯方式
 177   1        S3CON &= ~(1<<7); // 8位数据, 1位起始位, 1位停止位, 无校验
 178   1        IE2   |=  (1<<3); //允许中断
C51 COMPILER V9.60.0.0   MCU_UART                                                          05/31/2020 15:59:08 PAGE 4   

 179   1        S3CON |=  (1<<4); //允许接收
 180   1        P_SW2 &= ~2;    //切换到 P0.0 P0.1
 181   1      //  P_SW2 |= 2;     //切换到 P5.0 P5.1
 182   1      
 183   1        memset(RX3_Buffer,0,RX3_Length);
 184   1        B_TX3_Busy  = 0;
 185   1        RX3_len   = 0;
 186   1      }
 187          
 188          //========================================================================
 189          // 函数: void UART4_config(unsigned char brt)
 190          // 描述: UART4初始化函数。
 191          // 参数: brt: 选择波特率, 2: 使用Timer2做波特率, 其它值: 使用Timer4做波特率.
 192          // 返回: none.
 193          // 版本: VER1.0
 194          // 日期: 2020-03-08
 195          // 备注: 
 196          //========================================================================
 197          void  UART4_config(unsigned char brt) // 选择波特率, 2: 使用Timer2做波特率, 其它值: 使用Timer4做波特率.
 198          {
 199   1        /*********** 波特率固定使用定时器2 *****************/
 200   1        if(brt == 2)
 201   1        {
 202   2          S4CON &= ~(1<<6); //BRT select Timer2
 203   2          SetTimer2Baudraye(65536UL - (MAIN_Fosc / 4) / UART_BaudRate4);
 204   2        }
 205   1        /*********** 波特率使用定时器3 *****************/
 206   1        else
 207   1        {
 208   2          S4CON |= (1<<6);  //BRT select Timer4
 209   2          T4T3M &= 0x0f;    //停止计数, 清除控制位
 210   2          IE2   &= ~(1<<6); //禁止中断
 211   2          T4T3M |=  (1<<5); //1T
 212   2          T4T3M &= ~(1<<6); //定时
 213   2          T4T3M &= ~(1<<4); //不输出时钟
 214   2          TH4 = (65536UL - (MAIN_Fosc / 4) / UART_BaudRate4) / 256;
 215   2          TL4 = (65536UL - (MAIN_Fosc / 4) / UART_BaudRate4) % 256;
 216   2          T4T3M |=  (1<<7); //开始运行
 217   2        }
 218   1        
 219   1        S4CON &= ~(1<<5); //禁止多机通讯方式
 220   1        S4CON &= ~(1<<7); // 8位数据, 1位起始位, 1位停止位, 无校验
 221   1        IE2   |=  (1<<4); //允许中断
 222   1        S4CON |=  (1<<4); //允许接收
 223   1        P_SW2 &= ~4;    //切换到 P0.2 P0.3
 224   1      //  P_SW2 |= 4;     //切换到 P5.2 P5.3
 225   1      
 226   1        memset(RX4_Buffer,0,RX4_Length);
 227   1        B_TX4_Busy  = 0;
 228   1        RX4_len   = 0;
 229   1      }
 230          //========================================================================
 231          // 函数: SendString1(unsigned char *puts)
 232          // 描述: Uart1发送数据函数
 233          // 参数: *puts: 发送数据
 234          // 返回: none.
 235          // 版本: VER1.0
 236          // 日期: 2020-03-08
 237          // 备注: 
 238          //========================================================================
 239          void SendString1(unsigned char *puts)
 240          {
C51 COMPILER V9.60.0.0   MCU_UART                                                          05/31/2020 15:59:08 PAGE 5   

 241   1          for (; *puts != 0;  puts++)
 242   1          {
 243   2            B_TX1_Busy = 1;   //标志发送忙
 244   2            SBUF = *puts;   //发一个字节
 245   2            while(B_TX1_Busy);  //等待发送完成
 246   2          }
 247   1      }
 248          //========================================================================
 249          // 函数: SendString2(unsigned char *puts)
 250          // 描述: Uart1发送数据函数
 251          // 参数: *puts: 发送数据
 252          // 返回: none.
 253          // 版本: VER1.0
 254          // 日期: 2020-03-08
 255          // 备注: 
 256          //========================================================================
 257          void SendString2(unsigned char *puts)
 258          {
 259   1         for (; *puts != 0; puts++)
 260   1         {
 261   2            B_TX2_Busy = 1;   //标志发送忙
 262   2            S2BUF = *puts;    //发一个字节
 263   2            while(B_TX2_Busy);  //等待发送完成
 264   2          }
 265   1      }
 266          //========================================================================
 267          // 函数: SendString3(unsigned char *puts)
 268          // 描述: Uart1发送数据函数
 269          // 参数: *puts: 发送数据
 270          // 返回: none.
 271          // 版本: VER1.0
 272          // 日期: 2020-03-08
 273          // 备注: 
 274          //========================================================================
 275          void SendString3(unsigned char *puts)
 276          {
 277   1          for (; *puts != 0;  puts++)
 278   1          {
 279   2            B_TX3_Busy = 1;   //标志发送忙
 280   2            S3BUF = *puts;    //发一个字节
 281   2            while(B_TX3_Busy);  //等待发送完成
 282   2          }
 283   1      }
 284          //========================================================================
 285          // 函数: SendString4(unsigned char *puts)
 286          // 描述: Uart1发送数据函数
 287          // 参数: *puts: 发送数据
 288          // 返回: none.
 289          // 版本: VER1.0
 290          // 日期: 2020-03-08
 291          // 备注: 
 292          //========================================================================
 293          void SendString4(unsigned char *puts)
 294          {
 295   1          for (; *puts != 0;  puts++)
 296   1          {
 297   2            B_TX4_Busy = 1;   //标志发送忙
 298   2            S4BUF = *puts;    //发一个字节
 299   2            while(B_TX4_Busy);  //等待发送完成
 300   2          }
 301   1      }
 302          //========================================================================
C51 COMPILER V9.60.0.0   MCU_UART                                                          05/31/2020 15:59:08 PAGE 6   

 303          // 函数: void UART1_int (void) interrupt UART1_VECTOR
 304          // 描述: Uart1中断触发函数
 305          // 参数: none
 306          // 返回: none.
 307          // 版本: VER1.0
 308          // 日期: 2020-03-08
 309          // 备注: 
 310          //========================================================================
 311          void UART1_int (void) interrupt UART1_VECTOR
 312          {
 313   1        if(RI)
 314   1        {
 315   2          RI = 0;
 316   2          RX1_Buffer[RX1_len] = SBUF;
 317   2          if(++RX1_len >= RX1_Length) RX1_len = 0;
 318   2        }
 319   1      
 320   1        if(TI)
 321   1        {
 322   2          TI = 0;
 323   2          B_TX1_Busy = 0;
 324   2        }
 325   1      }
 326          //========================================================================
 327          // 函数: void UART2_int (void) interrupt UART2_VECTOR
 328          // 描述: Uart2中断触发函数
 329          // 参数: none
 330          // 返回: none.
 331          // 版本: VER1.0
 332          // 日期: 2020-03-08
 333          // 备注: 
 334          //========================================================================
 335          void UART2_int (void) interrupt UART2_VECTOR
 336          {
 337   1        if(RI2)
 338   1        {
 339   2          CLR_RI2();
 340   2          RX2_Buffer[RX2_len] = S2BUF;
 341   2          if(++RX2_len >= RX2_Length) RX2_len = 0;
 342   2        }
 343   1      
 344   1        if(TI2)
 345   1        {
 346   2          CLR_TI2();
 347   2          B_TX2_Busy = 0;
 348   2        }
 349   1      
 350   1      }
 351          //========================================================================
 352          // 函数: void UART3_int (void) interrupt UART3_VECTOR
 353          // 描述: Uart3中断触发函数
 354          // 参数: none
 355          // 返回: none.
 356          // 版本: VER1.0
 357          // 日期: 2020-03-08
 358          // 备注: 
 359          //========================================================================
 360          void UART3_int (void) interrupt UART3_VECTOR
 361          {
 362   1        if(RI3)
 363   1        {
 364   2          CLR_RI3();
C51 COMPILER V9.60.0.0   MCU_UART                                                          05/31/2020 15:59:08 PAGE 7   

 365   2          RX3_Buffer[RX3_len] = S3BUF;
 366   2          if(++RX3_len >= RX3_Length) RX3_len = 0;
 367   2        }
 368   1        if(TI3)
 369   1        {
 370   2          CLR_TI3();
 371   2          B_TX3_Busy = 0;
 372   2        }
 373   1      
 374   1      }
 375          
 376          //========================================================================
 377          // 函数: void UART4_int (void) interrupt UART4_VECTOR
 378          // 描述: Uart4中断触发函数
 379          // 参数: none
 380          // 返回: none.
 381          // 版本: VER1.0
 382          // 日期: 2020-03-08
 383          // 备注: 
 384          //========================================================================
 385          void UART4_int (void) interrupt UART4_VECTOR
 386          {
 387   1        if(RI4)
 388   1        {
 389   2          CLR_RI4();
 390   2          RX4_Buffer[RX4_len] = S4BUF;
 391   2          if(++RX4_len >= RX4_Length) RX4_len = 0;
 392   2        }
 393   1      
 394   1        if(TI4)
 395   1        {
 396   2          CLR_TI4();
 397   2          B_TX4_Busy = 0;
 398   2        }
 399   1      
 400   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    651    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   1024    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      4    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      4    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
