C51 COMPILER V9.60.0.0   MCU_UART                                                          05/31/2020 15:33:44 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE MCU_UART
OBJECT MODULE PLACED IN .\Objects\MCU_Uart.obj
COMPILER INVOKED BY: D:\Keil5\C51\BIN\C51.EXE MCU_Uart.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\MC
                    -U_Uart.lst) TABS(2) OBJECT(.\Objects\MCU_Uart.obj)

line level    source

   1          #include  "MCU_Uart.h"
   2          
   3          void  UART1_config(unsigned char brt);
   4          void  UART2_config(unsigned char brt);
   5          void  UART3_config(unsigned char brt);
   6          void  UART4_config(unsigned char brt);
   7          
   8          /*************  本地变量声明  **************/
   9          unsigned char xdata RX1_Buffer[RX1_Length]; //接收缓冲
  10          unsigned char xdata RX2_Buffer[RX2_Length]; //接收缓冲
  11          unsigned char xdata RX3_Buffer[RX3_Length]; //接收缓冲
  12          unsigned char xdata RX4_Buffer[RX4_Length]; //接收缓冲
  13          
  14          unsigned char RX1_len;  //接收数据长度
  15          unsigned char RX2_len;  //接收数据长度
  16          unsigned char RX3_len;  //接收数据长度
  17          unsigned char RX4_len;  //接收数据长度
  18          
  19          bit B_TX1_Busy,B_TX2_Busy,B_TX3_Busy,B_TX4_Busy;  // 发送忙标志
  20          //========================================================================
  21          // UART引脚说明:
  22          // UART1:(默认)P3^0,P3^1;   (可选)P3^6,P3^7; P1^6,P1^7;
  23          // UART2:(默认)P1^0,P1^1;   (可选)P4^6,P4^7;
  24          // UART3:(默认)P0^0,P0^1;   (可选)P5^0,P5^1;
  25          // UART4:(默认)P0^2,P0^3;   (可选)P5^2,P5^3;
  26          //========================================================================
  27          
  28          
  29          
  30          //========================================================================
  31          // 函数: void Uart_Init(void)
  32          // 描述: Uart初始化函数
  33          // 参数: 无
  34          // 返回: 无
  35          // 版本: V1.0, 2020.03.09
  36          //========================================================================
  37          void Uart_Init(void)
  38          {
  39   1        UART1_config(2);  // 选择波特率, 2: 使用Timer2做波特率, 其它值: 使用Timer1做波特率.
  40   1        UART2_config(2);  // 选择波特率, 2: 使用Timer2做波特率, 其它值: 无效.
  41   1        UART3_config(2);  // 选择波特率, 2: 使用Timer2做波特率, 其它值: 使用Timer3做波特率.
  42   1        UART4_config(2);  // 选择波特率, 2: 使用Timer2做波特率, 其它值: 使用Timer4做波特率.
  43   1        /*
  44   1        UART2_config(2);  // 选择波特率, 2: 使用Timer2做波特率, 其它值: 无效.
  45   1        UART3_config(3);  // 选择波特率, 2: 使用Timer2做波特率, 其它值: 使用Timer3做波特率.
  46   1        UART4_config(4);  // 选择波特率, 2: 使用Timer2做波特率, 其它值: 使用Timer4做波特率.
  47   1        */
  48   1      }
  49          //========================================================================
  50          // 函数: SetTimer2Baudraye(unsigned int dat)
  51          // 描述: 设置Timer2做波特率发生器。
  52          // 参数: dat: Timer2的重装值.
  53          // 返回: none.
  54          // 版本: VER1.0
C51 COMPILER V9.60.0.0   MCU_UART                                                          05/31/2020 15:33:44 PAGE 2   

  55          // 日期: 2020-03-08
  56          // 备注: 
  57          //========================================================================
  58          void  SetTimer2Baudraye(unsigned int dat) //使用Timer2做波特率
  59          {
  60   1        AUXR &= ~(1<<4);  //Timer stop
  61   1        AUXR &= ~(1<<3);  //Timer2 set As Timer
  62   1        AUXR |=  (1<<2);  //Timer2 set as 1T mode
  63   1        TH2 = dat / 256;
  64   1        TL2 = dat % 256;
  65   1        IE2  &= ~(1<<2);  //禁止中断
  66   1        AUXR |=  (1<<4);  //Timer run enable
  67   1      }
  68          
  69          //========================================================================
  70          // 函数: void UART1_config(unsigned char brt)
  71          // 描述: UART1初始化函数。
  72          // 参数: brt: 选择波特率, 2: 使用Timer2做波特率, 其它值: 使用Timer1做波特率.
  73          // 返回: none.
  74          // 版本: VER1.0
  75          // 日期: 2020-03-08
  76          // 备注: 
  77          //========================================================================
  78          void  UART1_config(unsigned char brt) 
  79          {
  80   1        /*********** 波特率使用定时器2 *****************/
  81   1        if(brt == 2)
  82   1        {
  83   2          AUXR |= 0x01;   //S1 BRT Use Timer2;
  84   2          SetTimer2Baudraye(65536UL - (MAIN_Fosc / 4) / UART_BaudRate1);
  85   2        }
  86   1      
  87   1        /*********** 波特率使用定时器1 *****************/
  88   1        else
  89   1        {
  90   2          TR1 = 0;
  91   2          AUXR &= ~0x01;    //S1 BRT Use Timer1;
  92   2          AUXR |=  (1<<6);  //Timer1 set as 1T mode
  93   2          TMOD &= ~(1<<6);  //Timer1 set As Timer
  94   2          TMOD &= ~0x30;    //Timer1_16bitAutoReload;
  95   2          TH1 = (65536UL - (MAIN_Fosc / 4) / UART_BaudRate1) / 256;
  96   2          TL1 = (65536UL - (MAIN_Fosc / 4) / UART_BaudRate1) % 256;
  97   2          ET1 = 0;  //禁止中断
  98   2          INT_CLKO &= ~0x02;  //不输出时钟
  99   2          TR1  = 1;
 100   2        }
 101   1        /*************************************************/
 102   1        SCON = (SCON & 0x3f) | (1<<6);  // 8位数据, 1位起始位, 1位停止位, 无校验
 103   1      //PS  = 1;  //高优先级中断
 104   1        ES  = 1;  //允许中断
 105   1        REN = 1;  //允许接收
 106   1        P_SW1 = P_SW1 & 0x3f; //切换到 P3.0 P3.1
 107   1      
 108   1      //P_SW1 = (P_SW1 & 0x3f) | (1<<6);  //切换到P3.6 P3.7
 109   1      //P_SW1 = (P_SW1 & 0x3f) | (2<<6);  //切换到P1.6 P1.7 (必须使用内部时钟)
 110   1      
 111   1        memset(RX1_Buffer,0,RX1_Length);
 112   1        B_TX1_Busy  = 0;
 113   1        RX1_len   = 0;
 114   1      }
 115          
 116          
C51 COMPILER V9.60.0.0   MCU_UART                                                          05/31/2020 15:33:44 PAGE 3   

 117          //========================================================================
 118          // 函数: void UART2_config(unsigned char brt)
 119          // 描述: UART2初始化函数。
 120          // 参数: brt: 选择波特率, 2: 使用Timer2(定时器工作方式1)做波特率, 其它值: 无效.
 121          // 返回: none.
 122          // 版本: VER1.0
 123          // 日期: 2020-03-08
 124          // 备注: 
 125          //========================================================================
 126          void  UART2_config(unsigned char brt) // 选择波特率, 2: 使用Timer2做波特率, 其它值: 无效.
 127          {
 128   1        /*********** 波特率固定使用定时器2 *****************/
 129   1        if(brt == 2)  SetTimer2Baudraye(65536UL - (MAIN_Fosc / 4) / UART_BaudRate2);
 130   1      
 131   1        S2CON &= ~(1<<7); // 8位数据, 1位起始位, 1位停止位, 无校验
 132   1        IE2   |= 1;     //允许中断
 133   1        S2CON |= (1<<4);  //允许接收
 134   1        P_SW2 &= ~1;    //切换到 P1.0 P1.1
 135   1      //P_SW2 |= 1;     //切换到 P4.6 P4.7
 136   1      
 137   1        memset(RX2_Buffer,0,RX2_Length);
 138   1        B_TX2_Busy  = 0;
 139   1        RX2_len   = 0;
 140   1      }
 141          
 142          //========================================================================
 143          // 函数: void UART3_config(unsigned char brt)
 144          // 描述: UART3初始化函数。
 145          // 参数: brt: 选择波特率, 2: 使用Timer2做波特率, 其它值: 使用Timer3做波特率.
 146          // 返回: none.
 147          // 版本: VER1.0
 148          // 日期: 2020-03-08
 149          // 备注: 
 150          //========================================================================
 151          void  UART3_config(unsigned char brt) // 选择波特率, 2: 使用Timer2做波特率, 其它值: 使用Timer3做波特率.
 152          {
 153   1        /*********** 波特率固定使用定时器2 *****************/
 154   1        if(brt == 2)
 155   1        {
 156   2          S3CON &= ~(1<<6); //BRT select Timer2
 157   2          SetTimer2Baudraye(65536UL - (MAIN_Fosc / 4) / UART_BaudRate3);
 158   2        }
 159   1        /*********** 波特率使用定时器3 *****************/
 160   1        else
 161   1        {
 162   2          S3CON |= (1<<6);  //BRT select Timer3
 163   2          T4T3M &= 0xf0;    //停止计数, 清除控制位
 164   2          IE2  &= ~(1<<5);  //禁止中断
 165   2          T4T3M |=  (1<<1); //1T
 166   2          T4T3M &= ~(1<<2); //定时
 167   2          T4T3M &= ~1;    //不输出时钟
 168   2          TH3 = (65536UL - (MAIN_Fosc / 4) / UART_BaudRate3) / 256;
 169   2          TL3 = (65536UL - (MAIN_Fosc / 4) / UART_BaudRate3) % 256;
 170   2          T4T3M |=  (1<<3); //开始运行
 171   2        }
 172   1        S3CON &= ~(1<<5); //禁止多机通讯方式
 173   1        S3CON &= ~(1<<7); // 8位数据, 1位起始位, 1位停止位, 无校验
 174   1        IE2   |=  (1<<3); //允许中断
 175   1        S3CON |=  (1<<4); //允许接收
 176   1        P_SW2 &= ~2;    //切换到 P0.0 P0.1
 177   1      //  P_SW2 |= 2;     //切换到 P5.0 P5.1
 178   1      
C51 COMPILER V9.60.0.0   MCU_UART                                                          05/31/2020 15:33:44 PAGE 4   

 179   1        memset(RX3_Buffer,0,RX3_Length);
 180   1        B_TX3_Busy  = 0;
 181   1        RX3_len   = 0;
 182   1      }
 183          
 184          //========================================================================
 185          // 函数: void UART4_config(unsigned char brt)
 186          // 描述: UART4初始化函数。
 187          // 参数: brt: 选择波特率, 2: 使用Timer2做波特率, 其它值: 使用Timer4做波特率.
 188          // 返回: none.
 189          // 版本: VER1.0
 190          // 日期: 2020-03-08
 191          // 备注: 
 192          //========================================================================
 193          void  UART4_config(unsigned char brt) // 选择波特率, 2: 使用Timer2做波特率, 其它值: 使用Timer4做波特率.
 194          {
 195   1        /*********** 波特率固定使用定时器2 *****************/
 196   1        if(brt == 2)
 197   1        {
 198   2          S4CON &= ~(1<<6); //BRT select Timer2
 199   2          SetTimer2Baudraye(65536UL - (MAIN_Fosc / 4) / UART_BaudRate4);
 200   2        }
 201   1        /*********** 波特率使用定时器3 *****************/
 202   1        else
 203   1        {
 204   2          S4CON |= (1<<6);  //BRT select Timer4
 205   2          T4T3M &= 0x0f;    //停止计数, 清除控制位
 206   2          IE2   &= ~(1<<6); //禁止中断
 207   2          T4T3M |=  (1<<5); //1T
 208   2          T4T3M &= ~(1<<6); //定时
 209   2          T4T3M &= ~(1<<4); //不输出时钟
 210   2          TH4 = (65536UL - (MAIN_Fosc / 4) / UART_BaudRate4) / 256;
 211   2          TL4 = (65536UL - (MAIN_Fosc / 4) / UART_BaudRate4) % 256;
 212   2          T4T3M |=  (1<<7); //开始运行
 213   2        }
 214   1        
 215   1        S4CON &= ~(1<<5); //禁止多机通讯方式
 216   1        S4CON &= ~(1<<7); // 8位数据, 1位起始位, 1位停止位, 无校验
 217   1        IE2   |=  (1<<4); //允许中断
 218   1        S4CON |=  (1<<4); //允许接收
 219   1        P_SW2 &= ~4;    //切换到 P0.2 P0.3
 220   1      //  P_SW2 |= 4;     //切换到 P5.2 P5.3
 221   1      
 222   1        memset(RX4_Buffer,0,RX4_Length);
 223   1        B_TX4_Busy  = 0;
 224   1        RX4_len   = 0;
 225   1      }
 226          //========================================================================
 227          // 函数: SendString1(unsigned char *puts)
 228          // 描述: Uart1发送数据函数
 229          // 参数: *puts: 发送数据
 230          // 返回: none.
 231          // 版本: VER1.0
 232          // 日期: 2020-03-08
 233          // 备注: 
 234          //========================================================================
 235          void SendString1(unsigned char *puts)
 236          {
 237   1          for (; *puts != 0;  puts++)
 238   1          {
 239   2            B_TX1_Busy = 1;   //标志发送忙
 240   2            SBUF = *puts;   //发一个字节
C51 COMPILER V9.60.0.0   MCU_UART                                                          05/31/2020 15:33:44 PAGE 5   

 241   2            while(B_TX1_Busy);  //等待发送完成
 242   2          }
 243   1      }
 244          //========================================================================
 245          // 函数: SendString2(unsigned char *puts)
 246          // 描述: Uart1发送数据函数
 247          // 参数: *puts: 发送数据
 248          // 返回: none.
 249          // 版本: VER1.0
 250          // 日期: 2020-03-08
 251          // 备注: 
 252          //========================================================================
 253          void SendString2(unsigned char *puts)
 254          {
 255   1         for (; *puts != 0; puts++)
 256   1         {
 257   2            B_TX2_Busy = 1;   //标志发送忙
 258   2            S2BUF = *puts;    //发一个字节
 259   2            while(B_TX2_Busy);  //等待发送完成
 260   2          }
 261   1      }
 262          //========================================================================
 263          // 函数: SendString3(unsigned char *puts)
 264          // 描述: Uart1发送数据函数
 265          // 参数: *puts: 发送数据
 266          // 返回: none.
 267          // 版本: VER1.0
 268          // 日期: 2020-03-08
 269          // 备注: 
 270          //========================================================================
 271          void SendString3(unsigned char *puts)
 272          {
 273   1          for (; *puts != 0;  puts++)
 274   1          {
 275   2            B_TX3_Busy = 1;   //标志发送忙
 276   2            S3BUF = *puts;    //发一个字节
 277   2            while(B_TX3_Busy);  //等待发送完成
 278   2          }
 279   1      }
 280          //========================================================================
 281          // 函数: SendString4(unsigned char *puts)
 282          // 描述: Uart1发送数据函数
 283          // 参数: *puts: 发送数据
 284          // 返回: none.
 285          // 版本: VER1.0
 286          // 日期: 2020-03-08
 287          // 备注: 
 288          //========================================================================
 289          void SendString4(unsigned char *puts)
 290          {
 291   1          for (; *puts != 0;  puts++)
 292   1          {
 293   2            B_TX4_Busy = 1;   //标志发送忙
 294   2            S4BUF = *puts;    //发一个字节
 295   2            while(B_TX4_Busy);  //等待发送完成
 296   2          }
 297   1      }
 298          //========================================================================
 299          // 函数: void UART1_int (void) interrupt UART1_VECTOR
 300          // 描述: Uart1中断触发函数
 301          // 参数: none
 302          // 返回: none.
C51 COMPILER V9.60.0.0   MCU_UART                                                          05/31/2020 15:33:44 PAGE 6   

 303          // 版本: VER1.0
 304          // 日期: 2020-03-08
 305          // 备注: 
 306          //========================================================================
 307          void UART1_int (void) interrupt UART1_VECTOR
 308          {
 309   1        if(RI)
 310   1        {
 311   2          RI = 0;
 312   2          RX1_Buffer[RX1_len] = SBUF;
 313   2          if(++RX1_len >= RX1_Length) RX1_len = 0;
 314   2        }
 315   1      
 316   1        if(TI)
 317   1        {
 318   2          TI = 0;
 319   2          B_TX1_Busy = 0;
 320   2        }
 321   1      }
 322          //========================================================================
 323          // 函数: void UART2_int (void) interrupt UART2_VECTOR
 324          // 描述: Uart2中断触发函数
 325          // 参数: none
 326          // 返回: none.
 327          // 版本: VER1.0
 328          // 日期: 2020-03-08
 329          // 备注: 
 330          //========================================================================
 331          void UART2_int (void) interrupt UART2_VECTOR
 332          {
 333   1        if(RI2)
 334   1        {
 335   2          CLR_RI2();
 336   2          RX2_Buffer[RX2_len] = S2BUF;
 337   2          if(++RX2_len >= RX2_Length) RX2_len = 0;
 338   2        }
 339   1      
 340   1        if(TI2)
 341   1        {
 342   2          CLR_TI2();
 343   2          B_TX2_Busy = 0;
 344   2        }
 345   1      
 346   1      }
 347          //========================================================================
 348          // 函数: void UART3_int (void) interrupt UART3_VECTOR
 349          // 描述: Uart3中断触发函数
 350          // 参数: none
 351          // 返回: none.
 352          // 版本: VER1.0
 353          // 日期: 2020-03-08
 354          // 备注: 
 355          //========================================================================
 356          void UART3_int (void) interrupt UART3_VECTOR
 357          {
 358   1        if(RI3)
 359   1        {
 360   2          CLR_RI3();
 361   2          RX3_Buffer[RX3_len] = S3BUF;
 362   2          if(++RX3_len >= RX3_Length) RX3_len = 0;
 363   2        }
 364   1        if(TI3)
C51 COMPILER V9.60.0.0   MCU_UART                                                          05/31/2020 15:33:44 PAGE 7   

 365   1        {
 366   2          CLR_TI3();
 367   2          B_TX3_Busy = 0;
 368   2        }
 369   1      
 370   1      }
 371          
 372          //========================================================================
 373          // 函数: void UART4_int (void) interrupt UART4_VECTOR
 374          // 描述: Uart4中断触发函数
 375          // 参数: none
 376          // 返回: none.
 377          // 版本: VER1.0
 378          // 日期: 2020-03-08
 379          // 备注: 
 380          //========================================================================
 381          void UART4_int (void) interrupt UART4_VECTOR
 382          {
 383   1        if(RI4)
 384   1        {
 385   2          CLR_RI4();
 386   2          RX4_Buffer[RX4_len] = S4BUF;
 387   2          if(++RX4_len >= RX4_Length) RX4_len = 0;
 388   2        }
 389   1      
 390   1        if(TI4)
 391   1        {
 392   2          CLR_TI4();
 393   2          B_TX4_Busy = 0;
 394   2        }
 395   1      
 396   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    651    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   1024    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      4    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      4    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
