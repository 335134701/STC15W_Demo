#include	"MCU_Config.h"

/*************	本地变量声明	**************/
u8 xdata	RX1_Buffer[RX1_Length];	//接收缓冲


u8 RX1_len;	//接收数据长度


bit B_TX1_Busy;	// 发送忙标志
//========================================================================
// UART引脚说明:
// UART1:(默认)P3^0,P3^1;		(可选)P3^6,P3^7; P1^6,P1^7;
//========================================================================

//========================================================================
// 函数: SetTimer2Baudraye(u16 dat)
// 描述: 设置Timer2做波特率发生器。
// 参数: dat: Timer2的重装值.
// 返回: none.
// 版本: VER1.0
// 日期: 2020-03-08
// 备注: 
//========================================================================
void	SetTimer2Baudraye(u16 dat)	//使用Timer2做波特率
{
	AUXR &= ~(1<<4);	//Timer stop
	AUXR &= ~(1<<3);	//Timer2 set As Timer
	AUXR |=  (1<<2);	//Timer2 set as 1T mode
	TH2 = dat / 256;
	TL2 = dat % 256;
	IE2  &= ~(1<<2);	//禁止中断
	AUXR |=  (1<<4);	//Timer run enable
}

//========================================================================
// 函数: void	UART1_config(u8 brt)
// 描述: UART1初始化函数。
// 参数: brt: 选择波特率, 2: 使用Timer2做波特率, 其它值: 使用Timer1做波特率.
// 返回: none.
// 版本: VER1.0
// 日期: 2020-03-08
// 备注: 
//========================================================================
void	UART1_config(u8 brt)	
{
	/*********** 波特率使用定时器2 *****************/
	if(brt == 2)
	{
		AUXR |= 0x01;		//S1 BRT Use Timer2;
		SetTimer2Baudraye(65536UL - (MAIN_Fosc / 4) / UART_BaudRate1);
	}

	/*********** 波特率使用定时器1 *****************/
	else
	{
		TR1 = 0;
		AUXR &= ~0x01;		//S1 BRT Use Timer1;
		AUXR |=  (1<<6);	//Timer1 set as 1T mode
		TMOD &= ~(1<<6);	//Timer1 set As Timer
		TMOD &= ~0x30;		//Timer1_16bitAutoReload;
		TH1 = (65536UL - (MAIN_Fosc / 4) / UART_BaudRate1) / 256;
		TL1 = (65536UL - (MAIN_Fosc / 4) / UART_BaudRate1) % 256;
		ET1 = 0;	//禁止中断
		INT_CLKO &= ~0x02;	//不输出时钟
		TR1  = 1;
	}
	/*************************************************/
	SCON = (SCON & 0x3f) | (1<<6);	// 8位数据, 1位起始位, 1位停止位, 无校验
//PS  = 1;	//高优先级中断
	ES  = 1;	//允许中断
	REN = 1;	//允许接收
	P_SW1 = P_SW1 & 0x3f;	//切换到 P3.0 P3.1
//P_SW1 = (P_SW1 & 0x3f) | (1<<6);	//切换到P3.6 P3.7
//P_SW1 = (P_SW1 & 0x3f) | (2<<6);	//切换到P1.6 P1.7 (必须使用内部时钟)

	memset(RX1_Buffer,0,RX1_Length);
	B_TX1_Busy  = 0;
	RX1_len   = 0;
}


//========================================================================
// 函数: SendString1(u8 *puts)
// 描述: Uart1发送数据函数
// 参数: *puts: 发送数据
// 返回: none.
// 版本: VER1.0
// 日期: 2020-03-08
// 备注: 
//========================================================================
void SendString1(u8 *puts)
{
    for (; *puts != 0;	puts++)
		{
			B_TX1_Busy = 1;		//标志发送忙
			SBUF = *puts;		//发一个字节
			while(B_TX1_Busy);	//等待发送完成
		}
}


//========================================================================
// 函数: Cl_RX_Buffer(u8 *puts,u8 *len)
// 描述: Uart清理函数
// 参数: *puts: 发送数据缓存，*len缓存中数据长度
// 返回: none.
// 版本: VER1.0
// 日期: 2020-03-08
// 备注: 
//========================================================================
void Cl_RX_Buffer(u8 *puts,u8 *len)
{
	*len=0;
	memset(puts,0,*len);
}


/********************* UART1中断函数************************/
void UART1_int (void) interrupt UART1_VECTOR
{
	if(RI)
	{
		RI = 0;
		RX1_Buffer[RX1_len] = SBUF;
		if(++RX1_len >= RX1_Length)	RX1_len = 0;
	}

	if(TI)
	{
		TI = 0;
		B_TX1_Busy = 0;
	}
}
